<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Контейнеры (crates) и модули (modules)</title>

    <link rel="stylesheet" type="text/css" href="../rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a  href='../src/getting-started.html'><b>3.</b> C чего начать</a>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ol class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a  href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ol>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>5.</b> Синтаксис и семантика</a>
<ol class='section'>
<li><a  href='../src/variable-bindings.html'><b>5.1.</b> Связывание имён</a>
</li>
<li><a  href='../src/functions.html'><b>5.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>5.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>5.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>5.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>5.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>5.7.</b> Владение</a>
</li>
<li><a  href='../src/references-and-borrowing.html'><b>5.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>5.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>5.10.</b> Изменяемость</a>
</li>
<li><a  href='../src/structs.html'><b>5.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>5.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>5.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>5.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>5.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>5.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>5.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>5.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>5.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>5.20.</b> Типаж `Drop`</a>
</li>
<li><a  href='../src/if-let.html'><b>5.21.</b> Конструкция `if let`</a>
</li>
<li><a  href='../src/trait-objects.html'><b>5.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>5.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>5.24.</b> Универсальный синтаксис вызова функций</a>
</li>
<li><a class='active' href='../src/crates-and-modules.html'><b>5.25.</b> Контейнеры и модули</a>
</li>
<li><a  href='../src/const-and-static.html'><b>5.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>5.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>5.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>5.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>5.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>5.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>5.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>5.33.</b> Преобразования при разыменовании</a>
</li>
<li><a  href='../src/macros.html'><b>5.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>5.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>5.36.</b> Небезопасный код</a>
</li>
</ol>
</li>
<li><a  href='../src/effective-rust.html'><b>6.</b> Эффективное использование Rust</a>
<ol class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>6.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>6.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>6.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>6.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>6.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>6.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>6.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>6.8.</b> Выбор гарантий</a>
</li>
<li><a  href='../src/ffi.html'><b>6.9.</b> Интерфейс внешних функций</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>6.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>6.11.</b> Каналы сборок</a>
</li>
<li><a  href='../src/using-rust-without-the-standard-library.html'><b>6.12.</b> Using Rust without the standard library</a>
</li>
</ol>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ol class='section'>
<li><a  href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a  href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
<li><a  href='../src/custom-allocators.html'><b>7.11.</b> Пользовательские менеджеры памяти</a>
</li>
</ol>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/syntax-index.html'><b>9.</b> Syntax Index</a>
</li>
<li><a  href='../src/bibliography.html'><b>10.</b> Библиография</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Контейнеры (crates) и модули (modules)</h1>
    <p>Когда проект начинает разрастаться, то хорошей практикой разработки программного
обеспечения считается: разбить его на небольшие кусочки, а затем собрать их
вместе. Также важно иметь четко определенный интерфейс, так как часть вашей
функциональности является приватной, а часть — публичной. Для облегчения такого
рода вещей Rust обладает модульной системой.</p>

<h1 id='Основные-термины-контейнеры-и-модули' class='section-header'><a href='#Основные-термины-контейнеры-и-модули'>Основные термины: контейнеры и модули</a></h1>
<p>Rust имеет два различных термина, которые относятся к модульной системе:
<em>контейнер</em> и <em>модуль</em>. Контейнер — это синоним <em>библиотеки</em> или <em>пакета</em> на
других языках. Именно поэтому инструмент управления пакетами в Rust называется
Cargo: вы пересылаете ваши контейнеры другим с помощью Cargo. Контейнеры могут
производить исполняемый файл или библиотеку, в зависимости от проекта.</p>

<p>Каждый контейнер имеет неявный <em>корневой модуль</em>, содержащий код для этого
контейнера. В рамках этого базового модуля можно определить дерево суб-модулей.
Модули позволяют разделить ваш код внутри контейнера.</p>

<p>В качестве примера, давайте сделаем контейнер <em>phrases</em>, который выдает нам
различные фразы на разных языках. Чтобы не усложнять пример, мы будем
использовать два вида фраз: «greetings» и «farewells», и два языка для этих
фраз: английский и японский (日本語). Мы будем использовать следующий шаблон
модуля:</p>

<pre><code class="language-text">                                    +-----------+
                                +---| greetings |
                                |   +-----------+
                  +---------+   |
              +---| english |---+
              |   +---------+   |   +-----------+
              |                 +---| farewells |
+---------+   |                     +-----------+
| phrases |---+
+---------+   |                     +-----------+
              |                 +---| greetings |
              |   +----------+  |   +-----------+
              +---| japanese |--+
                  +----------+  |
                                |   +-----------+
                                +---| farewells |
                                    +-----------+
</code></pre>

<p>В этом примере, <code>phrases</code> — это название нашего контейнера. Все остальное -
модули. Вы можете видеть, что они образуют дерево, в основании которого
располагается <em>корень</em> контейнера — <code>phrases</code>.</p>

<p>Теперь, когда у нас есть схема, давайте определим модули в коде. Для начала
создайте новый контейнер с помощью Cargo:</p>

<pre><code class="language-bash">$ cargo new phrases
$ cd phrases
</code></pre>

<p>Если вы помните, то эта команда создает простой проект:</p>

<pre><code class="language-bash">$ tree .
.
├── Cargo.toml
└── src
    └── lib.rs

1 directory, 2 files
</code></pre>

<p><code>src/lib.rs</code> — корень нашего контейнера, соответствующий <code>phrases</code> в нашей
диаграмме выше.</p>

<h1 id='Объявление-модулей' class='section-header'><a href='#Объявление-модулей'>Объявление модулей</a></h1>
<p>Для объявления каждого из наших модулей, мы используем ключевое слово <code>mod</code>.
Давайте сделаем, чтобы наш <code>src/lib.rs</code> выглядел следующим образом:</p>

<pre class="rust rust-example-rendered">
<span class="kw">mod</span> <span class="ident">english</span> {
    <span class="kw">mod</span> <span class="ident">greetings</span> {
    }

    <span class="kw">mod</span> <span class="ident">farewells</span> {
    }
}

<span class="kw">mod</span> <span class="ident">japanese</span> {
    <span class="kw">mod</span> <span class="ident">greetings</span> {
    }

    <span class="kw">mod</span> <span class="ident">farewells</span> {
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20english%20%7B%0A%20%20%20%20mod%20greetings%20%7B%0A%20%20%20%20%7D%0A%0A%20%20%20%20mod%20farewells%20%7B%0A%20%20%20%20%7D%0A%7D%0A%0Amod%20japanese%20%7B%0A%20%20%20%20mod%20greetings%20%7B%0A%20%20%20%20%7D%0A%0A%20%20%20%20mod%20farewells%20%7B%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>После ключевого слова <code>mod</code>, вы задаете имя модуля. Имена модулей следуют
соглашениям, как и другие идентификаторы Rust: <code>lower_snake_case</code>. Содержание
каждого модуля обрамляется в фигурные скобки (<code>{}</code>).</p>

<p>Внутри <code>mod</code> вы можете объявить суб-<code>mod</code>. Мы можем обращаться к суб-модулям с
помощью нотации (<code>::</code>). Так выглядят обращения к нашим четырем вложенным
модулям: <code>english::greetings</code>, <code>english::farewells</code>, <code>japanese::greetings</code> и
<code>japanese::farewells</code>. Так как суб-модули располагаются в пространстве имен
своих родительских модулей, то суб-модули <code>english::greetings</code> и
<code>japanese::greetings</code> не конфликтуют, несмотря на то, что они имеют одинаковые
имена, <code>greetings</code>.</p>

<p>Так как в этом контейнере нет функции <code>main()</code>, и называется он <code>lib.rs</code>, Cargo
соберет этот контейнер в виде библиотеки:</p>

<pre><code class="language-bash">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
$ ls target/debug
build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native
</code></pre>

<p><code>libphrase-hash.rlib</code> — это скомпилированный контейнер. Прежде чем мы
рассмотрим, как его можно использовать из другого контейнера, давайте
разобьем его на несколько файлов.</p>

<h1 id='Контейнеры-с-несколькими-файлами' class='section-header'><a href='#Контейнеры-с-несколькими-файлами'>Контейнеры с несколькими файлами</a></h1>
<p>Если бы каждый контейнер мог состоять только из одного файла, тогда этот файл
был бы очень большим. Зачастую легче разделить контейнер на несколько файлов, и
Rust поддерживает это двумя способами.</p>

<p>Вместо объявления модуля наподобие:</p>

<pre class="rust rust-example-rendered">
<span class="kw">mod</span> <span class="ident">english</span> {
    <span class="comment">// contents of our module go here</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20english%20%7B%0A%20%20%20%20%2F%2F%20contents%20of%20our%20module%20go%20here%0A%7D%0A%7D">Run</a></pre>

<p>Мы можем объявить наш модуль в виде:</p>

<pre class="rust rust-example-rendered">
<span class="kw">mod</span> <span class="ident">english</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20english%3B%0A%7D">Run</a></pre>

<p>Если мы это сделаем, то Rust будет ожидать, что найдет либо файл <code>english.rs</code>,
либо файл <code>english/mod.rs</code> с содержимым нашего модуля.</p>

<p>Обратите внимание, что в этих файлах вам не требуется заново объявлять модуль:
это уже сделано при изначальном объявлении <code>mod</code>.</p>

<p>С помощью этих двух приемов мы можем разбить наш контейнер на две директории и
семь файлов:</p>

<pre><code class="language-bash">$ tree .
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── english
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   ├── japanese
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   └── lib.rs
└── target
    └── debug
        ├── build
        ├── deps
        ├── examples
        ├── libphrases-a7448e02a0468eaa.rlib
        └── native
</code></pre>

<p><code>src/lib.rs</code> — корень нашего контейнера, и выглядит он следующим образом:</p>

<pre class="rust rust-example-rendered">
<span class="kw">mod</span> <span class="ident">english</span>;
<span class="kw">mod</span> <span class="ident">japanese</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20english%3B%0Amod%20japanese%3B%0A%7D">Run</a></pre>

<p>Эти два объявления информируют Rust, что следует искать: <code>src/english.rs</code> или
<code>src/english/mod.rs</code>, <code>src/japanese.rs</code> или <code>src/japanese/mod.rs</code>, в зависимости
от нашей структуры. В данном примере мы выбрали второй вариант из-за того, что
наши модули содержат суб-модули. И <code>src/english/mod.rs</code> и <code>src/japanese/mod.rs</code>
выглядят следующим образом:</p>

<pre class="rust rust-example-rendered">
<span class="kw">mod</span> <span class="ident">greetings</span>;
<span class="kw">mod</span> <span class="ident">farewells</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20greetings%3B%0Amod%20farewells%3B%0A%7D">Run</a></pre>

<p>В свою очередь, эти объявления информируют Rust, что следует искать:
<code>src/english/greetings.rs</code>, <code>src/japanese/greetings.rs</code>,
<code>src/english/farewells.rs</code>, <code>src/japanese/farewells.rs</code> или
<code>src/english/greetings/mod.rs</code>, <code>src/japanese/greetings/mod.rs</code>,
<code>src/english/farewells/mod.rs</code>, <code>src/japanese/farewells/mod.rs</code>. Так как эти
суб-модули не содержат свои собственные суб-модули, то мы выбрали
<code>src/english/greetings.rs</code> и <code>src/japanese/farewells.rs</code>. Вот так!</p>

<p>Содержание <code>src/english/greetings.rs</code> и <code>src/japanese/farewells.rs</code> являются
пустыми на данный момент. Давайте добавим несколько функций.</p>

<p>Поместите следующий код в <code>src/english/greetings.rs</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">hello</span>() <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="string">&quot;Hello!&quot;</span>.<span class="ident">to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20hello()%20-%3E%20String%20%7B%0A%20%20%20%20%22Hello!%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>Следующий код в <code>src/english/farewells.rs</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">goodbye</span>() <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="string">&quot;Goodbye.&quot;</span>.<span class="ident">to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20goodbye()%20-%3E%20String%20%7B%0A%20%20%20%20%22Goodbye.%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>Следующий код в <code>src/japanese/greetings.rs</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">hello</span>() <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="string">&quot;こんにちは&quot;</span>.<span class="ident">to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20hello()%20-%3E%20String%20%7B%0A%20%20%20%20%22%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>Конечно, вы можете скопировать и вставить этот код с этой страницы, или просто
напечатать что-нибудь еще. Вам совершенно не обязательно знать, что на японском
языке написано «Konnichiwa», чтобы понять как работает модульная система.</p>

<p>Поместите следующий код в <code>src/japanese/farewells.rs</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">goodbye</span>() <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="string">&quot;さようなら&quot;</span>.<span class="ident">to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20goodbye()%20-%3E%20String%20%7B%0A%20%20%20%20%22%E3%81%95%E3%82%88%E3%81%86%E3%81%AA%E3%82%89%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>(Это «Sayonara», если вам интересно.)</p>

<p>Теперь у нас есть некоторая функциональность в нашем контейнере, давайте
попробуем использовать его из другого контейнера.</p>

<h1 id='Импорт-внешних-контейнеров' class='section-header'><a href='#Импорт-внешних-контейнеров'>Импорт внешних контейнеров</a></h1>
<p>У нас есть библиотечный контейнер. Давайте создадим исполняемый контейнер,
который импортирует и использует нашу библиотеку.</p>

<p>Создайте файл <code>src/main.rs</code> и положите в него следующее: (при этом он не будет
компилироваться)</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">phrases</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello in English: {}&quot;</span>, <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">greetings</span>::<span class="ident">hello</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Goodbye in English: {}&quot;</span>, <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">farewells</span>::<span class="ident">goodbye</span>());

    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello in Japanese: {}&quot;</span>, <span class="ident">phrases</span>::<span class="ident">japanese</span>::<span class="ident">greetings</span>::<span class="ident">hello</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Goodbye in Japanese: {}&quot;</span>, <span class="ident">phrases</span>::<span class="ident">japanese</span>::<span class="ident">farewells</span>::<span class="ident">goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20phrases%3A%3Aenglish%3A%3Agreetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20phrases%3A%3Aenglish%3A%3Afarewells%3A%3Agoodbye())%3B%0A%0A%20%20%20%20println!(%22Hello%20in%20Japanese%3A%20%7B%7D%22%2C%20phrases%3A%3Ajapanese%3A%3Agreetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20Japanese%3A%20%7B%7D%22%2C%20phrases%3A%3Ajapanese%3A%3Afarewells%3A%3Agoodbye())%3B%0A%7D%0A">Run</a></pre>

<p>Объявление <code>extern crate</code> информирует Rust о том, что для компиляции и компоновки
кода нам нужен контейнер <code>phrases</code>. После этого объявление мы можем использовать
модули контейнера <code>phrases</code>. Как мы уже упоминали ранее, вы можете использовать
два подряд идущих символа двоеточия для обращения к суб-модулям и функциям
внутри них.</p>

<p>Кроме того, Cargo предполагает, что <code>src/main.rs</code> — это корень бинарного, а не
библиотечного контейнера. Теперь наш пакет содержит два контейнера: <code>src/lib.rs</code>
и <code>src/main.rs</code>. Этот шаблон является довольно распространенным для исполняемых
контейнеров: основная функциональность сосредоточена в библиотечном контейнере,
а исполняемый контейнер использует эту библиотеку. Таким образом, другие
программы также могут использовать библиотечный контейнер, к тому же такой
подход обеспечивает отделение интереса (разделение функциональности).</p>

<p>Хотя этот код все еще не работает. Мы получаем четыре ошибки, которые выглядят
примерно так:</p>

<pre><code class="language-bash">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:38: 4:72 error: function `hello` is private
src/main.rs:4     println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: in expansion of format_args!
&lt;std macros&gt;:2:25: 2:58 note: expansion site
&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
&lt;std macros&gt;:3:1: 3:54 note: expansion site
&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
phrases/src/main.rs:4:5: 4:76 note: expansion site
</code></pre>

<p>По умолчанию все элементы в Rust являются приватными. Давайте поговорим об этом
более подробно.</p>

<h1 id='Экспорт-публичных-интерфейсов' class='section-header'><a href='#Экспорт-публичных-интерфейсов'>Экспорт публичных интерфейсов</a></h1>
<p>Rust позволяет точно контролировать, какие элементы вашего интерфейса являются
публичными, и поэтому по умолчанию все элементы являются приватными. Чтобы
сделать элементы публичными, вы используете ключевое слово <code>pub</code>. Давайте
сначала сосредоточимся на модуле <code>english</code>, для чего сократим файл <code>src/main.rs</code>
до этого:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">phrases</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello in English: {}&quot;</span>, <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">greetings</span>::<span class="ident">hello</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Goodbye in English: {}&quot;</span>, <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">farewells</span>::<span class="ident">goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20phrases%3A%3Aenglish%3A%3Agreetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20phrases%3A%3Aenglish%3A%3Afarewells%3A%3Agoodbye())%3B%0A%7D%0A">Run</a></pre>

<p>В файле <code>src/lib.rs</code> в объявлении модуля <code>english</code> давайте добавим модификатор
<code>pub</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">english</span>;
<span class="kw">mod</span> <span class="ident">japanese</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20mod%20english%3B%0Amod%20japanese%3B%0A%7D">Run</a></pre>

<p>В файле <code>src/english/mod.rs</code> давайте сделаем оба модуля с модификатором <code>pub</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">greetings</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">farewells</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20mod%20greetings%3B%0Apub%20mod%20farewells%3B%0A%7D">Run</a></pre>

<p>В файле <code>src/english/greetings.rs</code> давайте добавим модификатор <code>pub</code> к
объявлению нашей функции <code>fn</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hello</span>() <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="string">&quot;Hello!&quot;</span>.<span class="ident">to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20hello()%20-%3E%20String%20%7B%0A%20%20%20%20%22Hello!%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>А также в файле <code>src/english/farewells.rs</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">goodbye</span>() <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="string">&quot;Goodbye.&quot;</span>.<span class="ident">to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20goodbye()%20-%3E%20String%20%7B%0A%20%20%20%20%22Goodbye.%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>Теперь наши контейнеры компилируются, хотя и с предупреждениями о том, что
функции в модуле <code>japanese</code> не используются:</p>

<pre><code class="language-bash">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hello`, #[warn(dead_code)] on by default
src/japanese/greetings.rs:1 fn hello() -&gt; String {
src/japanese/greetings.rs:2     &quot;こんにちは&quot;.to_string()
src/japanese/greetings.rs:3 }
src/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `goodbye`, #[warn(dead_code)] on by default
src/japanese/farewells.rs:1 fn goodbye() -&gt; String {
src/japanese/farewells.rs:2     &quot;さようなら&quot;.to_string()
src/japanese/farewells.rs:3 }
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
</code></pre>

<p>Теперь, когда функции являются публичными, мы можем их использовать. Отлично!
Тем не менее, написание <code>phrases::english::greetings::hello()</code> является очень
длинным и неудобным. Rust предоставляет другое ключевое слово, для импорта имен
в текущую область, чтобы для обращения можно было использовать короткие имена.
Давайте поговорим об этом ключевом слове, <code>use</code>.</p>

<h1 id='Импорт-модулей-с-помощью-use' class='section-header'><a href='#Импорт-модулей-с-помощью-use'>Импорт модулей с помощью <code>use</code></a></h1>
<p>Rust предоставляет ключевое слово <code>use</code>, которое позволяет импортировать имена в
нашу локальную область видимости. Давайте изменим файл <code>src/main.rs</code>, чтобы он
выглядел следующим образом:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">phrases</span>;

<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">greetings</span>;
<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">farewells</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello in English: {}&quot;</span>, <span class="ident">greetings</span>::<span class="ident">hello</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Goodbye in English: {}&quot;</span>, <span class="ident">farewells</span>::<span class="ident">goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Ause%20phrases%3A%3Aenglish%3A%3Agreetings%3B%0Ause%20phrases%3A%3Aenglish%3A%3Afarewells%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20greetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20farewells%3A%3Agoodbye())%3B%0A%7D%0A">Run</a></pre>

<p>Две строки, начинающиеся с <code>use</code>, импортируют соответствующие модули в локальную
область видимости, поэтому мы можем обратиться к функциям по гораздо более
коротким именам. По соглашению, при импорте функции, лучшей практикой считается
импортировать модуль, а не функцию непосредственно. Другими словами, вы <em>могли
бы</em> сделать следующее:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">phrases</span>;

<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">greetings</span>::<span class="ident">hello</span>;
<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">farewells</span>::<span class="ident">goodbye</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello in English: {}&quot;</span>, <span class="ident">hello</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Goodbye in English: {}&quot;</span>, <span class="ident">goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Ause%20phrases%3A%3Aenglish%3A%3Agreetings%3A%3Ahello%3B%0Ause%20phrases%3A%3Aenglish%3A%3Afarewells%3A%3Agoodbye%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20hello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20goodbye())%3B%0A%7D%0A">Run</a></pre>

<p>Но такой подход не является идиоматическим. Он значительно чаще приводит к
конфликту имен. Для нашей короткой программы это не так важно, но, как только
программа разрастается, это становится проблемой. Если у нас возникает конфликт
имен, то Rust выдает ошибку компиляции. Например, если мы сделаем функции
<code>japanese</code> публичными, и пытаемся скомпилировать этот код:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">phrases</span>;

<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">greetings</span>::<span class="ident">hello</span>;
<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">japanese</span>::<span class="ident">greetings</span>::<span class="ident">hello</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello in English: {}&quot;</span>, <span class="ident">hello</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello in Japanese: {}&quot;</span>, <span class="ident">hello</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Ause%20phrases%3A%3Aenglish%3A%3Agreetings%3A%3Ahello%3B%0Ause%20phrases%3A%3Ajapanese%3A%3Agreetings%3A%3Ahello%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20hello())%3B%0A%20%20%20%20println!(%22Hello%20in%20Japanese%3A%20%7B%7D%22%2C%20hello())%3B%0A%7D%0A">Run</a></pre>

<p>Rust выдаст нам сообщение об ошибке во время компиляции:</p>

<pre><code class="language-text">   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module [E0252]
src/main.rs:4 use phrases::japanese::greetings::hello;
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `phrases`.
</code></pre>

<p>Если мы импортируем несколько имен из одного модуля, то нам совсем не
обязательно писать одно и то же много раз. Вместо этого кода:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">greetings</span>;
<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">english</span>::<span class="ident">farewells</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20phrases%3A%3Aenglish%3A%3Agreetings%3B%0Ause%20phrases%3A%3Aenglish%3A%3Afarewells%3B%0A%7D">Run</a></pre>

<p>Вы можете использовать сокращение:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">english</span>::{<span class="ident">greetings</span>, <span class="ident">farewells</span>};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20phrases%3A%3Aenglish%3A%3A%7Bgreetings%2C%20farewells%7D%3B%0A%7D">Run</a></pre>

<h2 id='Реэкспорт-с-помощью-pub-use' class='section-header'><a href='#Реэкспорт-с-помощью-pub-use'>Реэкспорт с помощью <code>pub use</code></a></h2>
<p>Вы можете использовать <code>use</code> не просто для сокращения идентификаторов. Вы также
можете использовать его внутри вашего контейнера, чтобы реэкспортировать функцию
из другого модуля. Это позволяет представить внешний интерфейс, который может не
напрямую отображать внутреннюю организацию кода.</p>

<p>Давайте посмотрим на примере. Измените файл <code>src/main.rs</code> следующим образом:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">phrases</span>;

<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">english</span>::{<span class="ident">greetings</span>,<span class="ident">farewells</span>};
<span class="kw">use</span> <span class="ident">phrases</span>::<span class="ident">japanese</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello in English: {}&quot;</span>, <span class="ident">greetings</span>::<span class="ident">hello</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Goodbye in English: {}&quot;</span>, <span class="ident">farewells</span>::<span class="ident">goodbye</span>());

    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hello in Japanese: {}&quot;</span>, <span class="ident">japanese</span>::<span class="ident">hello</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Goodbye in Japanese: {}&quot;</span>, <span class="ident">japanese</span>::<span class="ident">goodbye</span>());
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20crate%20phrases%3B%0A%0Ause%20phrases%3A%3Aenglish%3A%3A%7Bgreetings%2Cfarewells%7D%3B%0Ause%20phrases%3A%3Ajapanese%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%20in%20English%3A%20%7B%7D%22%2C%20greetings%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20English%3A%20%7B%7D%22%2C%20farewells%3A%3Agoodbye())%3B%0A%0A%20%20%20%20println!(%22Hello%20in%20Japanese%3A%20%7B%7D%22%2C%20japanese%3A%3Ahello())%3B%0A%20%20%20%20println!(%22Goodbye%20in%20Japanese%3A%20%7B%7D%22%2C%20japanese%3A%3Agoodbye())%3B%0A%7D%0A">Run</a></pre>

<p>Затем измените файл <code>src/lib.rs</code>, чтобы сделать модуль <code>japanese</code> с публичным:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">english</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">japanese</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20mod%20english%3B%0Apub%20mod%20japanese%3B%0A%7D">Run</a></pre>

<p>Далее, убедитесь, что обе функции публичные, сперва в
<code>src/japanese/greetings.rs</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hello</span>() <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="string">&quot;こんにちは&quot;</span>.<span class="ident">to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20hello()%20-%3E%20String%20%7B%0A%20%20%20%20%22%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>А затем в <code>src/japanese/farewells.rs</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">goodbye</span>() <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="string">&quot;さようなら&quot;</span>.<span class="ident">to_string</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20fn%20goodbye()%20-%3E%20String%20%7B%0A%20%20%20%20%22%E3%81%95%E3%82%88%E3%81%86%E3%81%AA%E3%82%89%22.to_string()%0A%7D%0A%7D">Run</a></pre>

<p>Наконец, измените файл <code>src/japanese/mod.rs</code> вот так:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">greetings</span>::<span class="ident">hello</span>;
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::<span class="ident">farewells</span>::<span class="ident">goodbye</span>;

<span class="kw">mod</span> <span class="ident">greetings</span>;
<span class="kw">mod</span> <span class="ident">farewells</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Apub%20use%20self%3A%3Agreetings%3A%3Ahello%3B%0Apub%20use%20self%3A%3Afarewells%3A%3Agoodbye%3B%0A%0Amod%20greetings%3B%0Amod%20farewells%3B%0A%7D">Run</a></pre>

<p>Объявление <code>pub use</code> привносит указанную функцию в эту часть области видимости
нашей модульной иерархии. Так как мы использовали <code>pub use</code> внутри нашего модуля
<code>japanese</code>, то теперь мы можем вызывать функцию <code>phrases::japanese::hello()</code> и
функцию <code>phrases::japanese::goodbye()</code>, хотя код для них расположен в
<code>phrases::japanese::greetings::hello()</code> и
<code>phrases::japanese::farewells::goodbye()</code> соответственно. Наша внутренняя
организация не определяет наш внешний интерфейс.</p>

<p>В этом примере мы используем <code>pub use</code> отдельно для каждой функции, которую
хотим привнести в область <code>japanese</code>. В качестве альтернативы, мы могли бы
использовать шаблонный синтаксис, чтобы включать в себя все элементы из модуля
<code>greetings</code> в текущую область: <code>pub use self::greetings::*</code>.</p>

<p>Что можно сказать о <code>self</code>? По умолчанию объявления <code>use</code> используют абсолютные
пути, начинающиеся с корня контейнера. <code>self</code>, напротив, формирует эти пути
относительно текущего места в иерархии. У <code>use</code> есть еще одна особая форма: вы
можете использовать <code>use super::</code>, чтобы подняться по дереву на один уровень
вверх от вашего текущего местоположения. Некоторые предпочитают думать о <code>self</code>
как о <code>.</code>, а о <code>super</code> как о <code>..</code>, что для многих командных оболочек является
представлением для текущей директории и для родительской директории
соответственно.</p>

<p>Вне <code>use</code>, пути относительны: <code>foo::bar()</code> ссылаться на функцию внутри <code>foo</code>
относительно того, где мы находимся. Если же используется префикс <code>::</code>, то
<code>::foo::bar()</code> будет ссылаться на другой <code>foo</code>, абсолютный путь относительно
корня контейнера.</p>

<p>Кроме того, обратите внимание, что мы использовали <code>pub use</code> прежде, чем
объявили наши модули с помощью <code>mod</code>. Rust требует, чтобы объявления <code>use</code> шли в
первую очередь.</p>

<p>Следующий код собирается и работает:</p>

<pre><code class="language-bash">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
Hello in Japanese: こんにちは
Goodbye in Japanese: さようなら
</code></pre>

    <script src='../rustbook.js'></script>
</div></div>


</body>
</html>