<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Функции</title>

    <link rel="stylesheet" type="text/css" href="../rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a  href='../src/getting-started.html'><b>3.</b> C чего начать</a>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ol class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a  href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ol>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>5.</b> Синтаксис и семантика</a>
<ol class='section'>
<li><a  href='../src/variable-bindings.html'><b>5.1.</b> Связывание имён</a>
</li>
<li><a class='active' href='../src/functions.html'><b>5.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>5.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>5.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>5.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>5.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>5.7.</b> Владение</a>
</li>
<li><a  href='../src/references-and-borrowing.html'><b>5.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>5.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>5.10.</b> Изменяемость</a>
</li>
<li><a  href='../src/structs.html'><b>5.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>5.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>5.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>5.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>5.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>5.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>5.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>5.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>5.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>5.20.</b> Типаж `Drop`</a>
</li>
<li><a  href='../src/if-let.html'><b>5.21.</b> Конструкция `if let`</a>
</li>
<li><a  href='../src/trait-objects.html'><b>5.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>5.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>5.24.</b> Универсальный синтаксис вызова функций</a>
</li>
<li><a  href='../src/crates-and-modules.html'><b>5.25.</b> Контейнеры и модули</a>
</li>
<li><a  href='../src/const-and-static.html'><b>5.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>5.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>5.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>5.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>5.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>5.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>5.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>5.33.</b> Преобразования при разыменовании</a>
</li>
<li><a  href='../src/macros.html'><b>5.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>5.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>5.36.</b> Небезопасный код</a>
</li>
</ol>
</li>
<li><a  href='../src/effective-rust.html'><b>6.</b> Эффективное использование Rust</a>
<ol class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>6.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>6.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>6.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>6.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>6.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>6.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>6.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>6.8.</b> Выбор гарантий</a>
</li>
<li><a  href='../src/ffi.html'><b>6.9.</b> Интерфейс внешних функций</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>6.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>6.11.</b> Каналы сборок</a>
</li>
<li><a  href='../src/using-rust-without-the-standard-library.html'><b>6.12.</b> Using Rust without the standard library</a>
</li>
</ol>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ol class='section'>
<li><a  href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a  href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
<li><a  href='../src/custom-allocators.html'><b>7.11.</b> Пользовательские менеджеры памяти</a>
</li>
</ol>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/syntax-index.html'><b>9.</b> Syntax Index</a>
</li>
<li><a  href='../src/bibliography.html'><b>10.</b> Библиография</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Функции</h1>
    <p>Каждая программа на Rust имеет по крайней мере одну функцию — <code>main</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%7D%0A">Run</a></pre>

<p>Это простейшее объявление функции. Как мы упоминали ранее, ключевое слово <code>fn</code>
объявляет функцию. За ним следует её имя, пустые круглые скобки (поскольку эта
функция не принимает аргументов), а затем тело функции, заключённое в фигурные
скобки. Вот функция <code>foo</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>() {
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo()%20%7B%0A%7D%0A%7D">Run</a></pre>

<p>Итак, что насчёт аргументов, принимаемых функцией? Вот функция, печатающая
число:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">print_number</span>(<span class="ident">x</span>: <span class="ident">i32</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;x равен: {}&quot;</span>, <span class="ident">x</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20print_number(x%3A%20i32)%20%7B%0A%20%20%20%20println!(%22x%20%D1%80%D0%B0%D0%B2%D0%B5%D0%BD%3A%20%7B%7D%22%2C%20x)%3B%0A%7D%0A%7D">Run</a></pre>

<p>Вот полная программа, использующая функцию <code>print_number</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="ident">print_number</span>(<span class="number">5</span>);
}

<span class="kw">fn</span> <span class="ident">print_number</span>(<span class="ident">x</span>: <span class="ident">i32</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;x равен: {}&quot;</span>, <span class="ident">x</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%20%20%20%20print_number(5)%3B%0A%7D%0A%0Afn%20print_number(x%3A%20i32)%20%7B%0A%20%20%20%20println!(%22x%20%D1%80%D0%B0%D0%B2%D0%B5%D0%BD%3A%20%7B%7D%22%2C%20x)%3B%0A%7D%0A">Run</a></pre>

<p>Как видите, аргументы функций похожи на операторы <code>let</code>: вы можете объявить тип
аргумента после двоеточия.</p>

<p>Вот полная программа, которая складывает два числа и печатает их:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="ident">print_sum</span>(<span class="number">5</span>, <span class="number">6</span>);
}

<span class="kw">fn</span> <span class="ident">print_sum</span>(<span class="ident">x</span>: <span class="ident">i32</span>, <span class="ident">y</span>: <span class="ident">i32</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;сумма чисел: {}&quot;</span>, <span class="ident">x</span> <span class="op">+</span> <span class="ident">y</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%20%20%20%20print_sum(5%2C%206)%3B%0A%7D%0A%0Afn%20print_sum(x%3A%20i32%2C%20y%3A%20i32)%20%7B%0A%20%20%20%20println!(%22%D1%81%D1%83%D0%BC%D0%BC%D0%B0%20%D1%87%D0%B8%D1%81%D0%B5%D0%BB%3A%20%7B%7D%22%2C%20x%20%2B%20y)%3B%0A%7D%0A">Run</a></pre>

<p>Аргументы разделяются запятой — и при вызове функции, и при её объявлении.</p>

<p>В отличие от <code>let</code>, вы <em>должны</em> объявлять типы аргументов функции. Этот код не
скомпилируется:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">print_sum</span>(<span class="ident">x</span>, <span class="ident">y</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;сумма чисел: {}&quot;</span>, <span class="ident">x</span> <span class="op">+</span> <span class="ident">y</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20print_sum(x%2C%20y)%20%7B%0A%20%20%20%20println!(%22%D1%81%D1%83%D0%BC%D0%BC%D0%B0%20%D1%87%D0%B8%D1%81%D0%B5%D0%BB%3A%20%7B%7D%22%2C%20x%20%2B%20y)%3B%0A%7D%0A%7D">Run</a></pre>

<p>Вы увидите такую ошибку:</p>

<pre><code class="language-text">expected one of `!`, `:`, or `@`, found `)`
fn print_number(x, y) {
</code></pre>

<p>Это осознанное решение при проектировании языка. Бесспорно, вывод типов во всей
программе возможен. Однако даже в Haskell считается хорошим стилем явно
документировать типы функций, хотя в этом языке и возможен полный вывод типов.
Мы считаем, что принудительное объявление типов функций при сохранении
локального вывода типов — это хороший компромисс.</p>

<p>Как насчёт возвращаемого значения? Вот функция, которая прибавляет один к
целому:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">add_one</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20add_one(x%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20x%20%2B%201%0A%7D%0A%7D">Run</a></pre>

<p>Функции в Rust возвращают ровно одно значение, тип которого объявляется после
«стрелки». «Стрелка» представляет собой дефис (<code>-</code>), за которым следует знак
«больше» (<code>&gt;</code>). Заметьте, что в функции выше нет точки с запятой. Если бы мы
добавили её:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">add_one</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20add_one(x%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20x%20%2B%201%3B%0A%7D%0A%7D">Run</a></pre>

<p>мы бы получили ошибку:</p>

<pre><code class="language-text">error: not all control paths return a value
fn add_one(x: i32) -&gt; i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
</code></pre>

<p>Здесь показаны две интересные особенности Rust. Во-первых, это язык,
ориентированный на выражения, и во-вторых, смысл точки с запятой отличается от
смысла аналогичного символа в других языках с синтаксисом на основе фигурных
скобок и точки с запятой. Эти две особенности связаны.</p>

<p><a name="expressions-vs-statements"></a></p>

<h2 id='Выражения-и-операторы' class='section-header'><a href='#Выражения-и-операторы'>Выражения и операторы</a></h2>
<p>Rust — в первую очередь язык, ориентированный на выражения. Есть только два типа
операторов, а всё остальное является выражением.</p>

<p>А в чём же разница? Выражение возвращает значение, в то время как оператор -
нет. Вот почему мы получаем здесь «not all control paths return a value»:
оператор <code>х + 1;</code> не возвращает значение. Есть два типа операторов в Rust:
«операторы объявления» и «операторы выражения». Все остальное — выражения.
Давайте сначала поговорим об операторах объявления.</p>

<p><em>Оператор объявления</em> — это связывание. В некоторых языках связывание переменных
может быть записано как выражение, а не только как оператор. Например, в Ruby:</p>

<pre><code class="language-ruby">x = y = 5
</code></pre>

<p>Однако, в Rust использование <code>let</code> для связывания <em>не является</em> выражением.
Следующий код вызовет ошибку компиляции:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> (<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="number">5</span>); <span class="comment">// expected identifier, found keyword `let`</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20x%20%3D%20(let%20y%20%3D%205)%3B%20%2F%2F%20expected%20identifier%2C%20found%20keyword%20%60let%60%0A%7D">Run</a></pre>

<p>Здесь компилятор сообщил нам, что ожидал увидеть выражение, но <code>let</code> является
оператором, а не выражением.</p>

<p>Обратите внимание, что присвоение уже связанной переменной (например: <code>y = 5</code>)
является выражением, но его значение не особенно полезно. В отличие от других
языков, где результатом присваивания является присваиваемое значение (например,
<code>5</code> из предыдущего примера), в Rust значением присваивания является пустой
кортеж <code>()</code>.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">y</span> <span class="op">=</span> <span class="number">5</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> (<span class="ident">y</span> <span class="op">=</span> <span class="number">6</span>);  <span class="comment">// x будет присвоено значение `()`, а не `6`</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20y%20%3D%205%3B%0A%0Alet%20x%20%3D%20(y%20%3D%206)%3B%20%20%2F%2F%20x%20%D0%B1%D1%83%D0%B4%D0%B5%D1%82%20%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%BE%D0%B5%D0%BD%D0%BE%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%60()%60%2C%20%D0%B0%20%D0%BD%D0%B5%20%606%60%0A%7D">Run</a></pre>

<p>Вторым типом операторов в Rust является <em>оператор выражения</em>. Его цель -
превратить любое выражение в оператор. В практическом плане, грамматика Rust
ожидает, что за операторами будут идти другие операторы. Это означает, что вы
используете точку с запятой для отделения выражений друг от друга. Rust выглядит
как многие другие языки, которые требуют использовать точку с запятой в конце
каждой строки. Вы увидите её в конце почти каждой строки кода на Rust.</p>

<p>Из-за чего мы говорим «почти»? Вы это уже видели в этом примере:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">add_one</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20add_one(x%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20x%20%2B%201%0A%7D%0A%7D">Run</a></pre>

<p>Наша функция объявлена как возвращающая <code>i32</code>. Но если в конце есть точка с
запятой, то вместо этого функция вернёт <code>()</code>. Компилятор Rust обрабатывает эту
ситуацию и предлагает удалить точку с запятой.</p>

<h2 id='Досрочный-возврат-из-функции' class='section-header'><a href='#Досрочный-возврат-из-функции'>Досрочный возврат из функции</a></h2>
<p>А что насчёт досрочного возврата из функции? У нас есть для этого ключевое слово
<code>return</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="kw">return</span> <span class="ident">x</span>;

    <span class="comment">// дальнейший код не будет исполнен!</span>
    <span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo(x%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%3B%0A%0A%20%20%20%20%2F%2F%20%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B5%D0%B9%D1%88%D0%B8%D0%B9%20%D0%BA%D0%BE%D0%B4%20%D0%BD%D0%B5%20%D0%B1%D1%83%D0%B4%D0%B5%D1%82%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD!%0A%20%20%20%20x%20%2B%201%0A%7D%0A%7D">Run</a></pre>

<p><code>return</code> можно написать в последней строке тела функции, но это считается
плохим стилем:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="kw">return</span> <span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo(x%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%201%3B%0A%7D%0A%7D">Run</a></pre>

<p>Если вы никогда не работали с языком, в котором операторы являются выражениями,
предыдущее определение без <code>return</code> может показаться вам странным. Но со
временем вы просто перестанете замечать это.</p>

<h2 id='Расходящиеся-функции' class='section-header'><a href='#Расходящиеся-функции'>Расходящиеся функции</a></h2>
<p>Для функций, которые не возвращают управление («расходящихся»), в Rust есть
специальный синтаксис:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">diverges</span>() <span class="op">-&gt;</span> <span class="op">!</span> {
    <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;Эта функция не возвращает управление!&quot;</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20diverges()%20-%3E%20!%20%7B%0A%20%20%20%20panic!(%22%D0%AD%D1%82%D0%B0%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%20%D0%BD%D0%B5%20%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D1%82%20%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5!%22)%3B%0A%7D%0A%7D">Run</a></pre>

<p><code>panic!</code> — это макрос, как и <code>println!()</code>, который мы встречали ранее. В отличие
от <code>println!()</code>, <code>panic!()</code> вызывает остановку текущего потока исполнения с
заданным сообщением. Поскольку эта функция вызывает остановку исполнения, она
никогда не вернёт управление. Поэтому тип её возвращаемого значения обозначается
знаком <code>!</code> и читается как «расходится».</p>

<p>Если добавить функцию <code>diverges()</code> и запустить её, то вы получите следующее
сообщение:</p>

<pre><code class="language-text">thread ‘&lt;main&gt;’ panicked at ‘Эта функция не возвращает управление!’, hello.rs:2
</code></pre>

<p>Для получение более подробной информации вы можете посмотреть трассировку
установив переменную среды <code>RUST_BACKTRACE</code>:</p>

<pre><code class="language-text">$ RUST_BACKTRACE=1 ./diverges
thread &#39;&lt;main&gt;&#39; panicked at &#39;Эта функция не возвращает управление!&#39;, hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>

<p><code>RUST_BACKTRACE</code> также работает при выполнении команды <code>run</code>:</p>

<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
     Running `target/debug/diverges`
thread &#39;&lt;main&gt;&#39; panicked at &#39;Эта функция не возвращает управление!&#39;, hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>

<p>Значение расходящейся функции может быть использовано как значение любого типа:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="ident">diverges</span>();
<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">String</span> <span class="op">=</span> <span class="ident">diverges</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20diverges()%20-%3E%20!%20%7B%0A%20%20%20panic!(%22%D0%AD%D1%82%D0%B0%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%20%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0%20%D0%BD%D0%B5%20%D0%B2%D1%8B%D1%85%D0%BE%D0%B4%D0%B8%D1%82!%22)%3B%0A%7D%0Alet%20x%3A%20i32%20%3D%20diverges()%3B%0Alet%20x%3A%20String%20%3D%20diverges()%3B%0A%7D">Run</a></pre>

<h2 id='Указатели-на-функции' class='section-header'><a href='#Указатели-на-функции'>Указатели на функции</a></h2>
<p>Можно объявить имя, связанное с функцией:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span>: <span class="kw">fn</span>(<span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20f%3A%20fn(i32)%20-%3E%20i32%3B%0A%7D">Run</a></pre>

<p><code>f</code> — это имя, связанное с указателем на функцию, которая принимает в качестве
аргумента <code>i32</code> и возвращает <code>i32</code>. Например:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="ident">i</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="ident">i</span> <span class="op">+</span> <span class="number">1</span>
}

<span class="comment">// без вывода типа</span>
<span class="kw">let</span> <span class="ident">f</span>: <span class="kw">fn</span>(<span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> <span class="op">=</span> <span class="ident">plus_one</span>;

<span class="comment">// с выводом типа</span>
<span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">plus_one</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20plus_one(i%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20i%20%2B%201%0A%7D%0A%0A%2F%2F%20%D0%B1%D0%B5%D0%B7%20%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0%20%D1%82%D0%B8%D0%BF%D0%B0%0Alet%20f%3A%20fn(i32)%20-%3E%20i32%20%3D%20plus_one%3B%0A%0A%2F%2F%20%D1%81%20%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%BE%D0%BC%20%D1%82%D0%B8%D0%BF%D0%B0%0Alet%20f%20%3D%20plus_one%3B%0A%7D">Run</a></pre>

<p>Теперь мы можем использовать <code>f</code>, чтобы вызвать функцию:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">six</span> <span class="op">=</span> <span class="ident">f</span>(<span class="number">5</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20plus_one(i%3A%20i32)%20-%3E%20i32%20%7B%20i%20%2B%201%20%7D%0Alet%20f%20%3D%20plus_one%3B%0Alet%20six%20%3D%20f(5)%3B%0A%7D">Run</a></pre>

    <script src='../rustbook.js'></script>
</div></div>


</body>
</html>