<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Ссылки и заимствование</title>

    <link rel="stylesheet" type="text/css" href="../rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a  href='../src/getting-started.html'><b>3.</b> C чего начать</a>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ol class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a  href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ol>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>5.</b> Синтаксис и семантика</a>
<ol class='section'>
<li><a  href='../src/variable-bindings.html'><b>5.1.</b> Связывание имён</a>
</li>
<li><a  href='../src/functions.html'><b>5.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>5.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>5.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>5.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>5.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>5.7.</b> Владение</a>
</li>
<li><a class='active' href='../src/references-and-borrowing.html'><b>5.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>5.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>5.10.</b> Изменяемость</a>
</li>
<li><a  href='../src/structs.html'><b>5.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>5.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>5.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>5.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>5.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>5.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>5.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>5.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>5.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>5.20.</b> Типаж `Drop`</a>
</li>
<li><a  href='../src/if-let.html'><b>5.21.</b> Конструкция `if let`</a>
</li>
<li><a  href='../src/trait-objects.html'><b>5.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>5.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>5.24.</b> Универсальный синтаксис вызова функций</a>
</li>
<li><a  href='../src/crates-and-modules.html'><b>5.25.</b> Контейнеры и модули</a>
</li>
<li><a  href='../src/const-and-static.html'><b>5.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>5.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>5.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>5.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>5.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>5.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>5.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>5.33.</b> Преобразования при разыменовании</a>
</li>
<li><a  href='../src/macros.html'><b>5.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>5.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>5.36.</b> Небезопасный код</a>
</li>
</ol>
</li>
<li><a  href='../src/effective-rust.html'><b>6.</b> Эффективное использование Rust</a>
<ol class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>6.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>6.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>6.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>6.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>6.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>6.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>6.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>6.8.</b> Выбор гарантий</a>
</li>
<li><a  href='../src/ffi.html'><b>6.9.</b> Интерфейс внешних функций</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>6.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>6.11.</b> Каналы сборок</a>
</li>
<li><a  href='../src/using-rust-without-the-standard-library.html'><b>6.12.</b> Using Rust without the standard library</a>
</li>
</ol>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ol class='section'>
<li><a  href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a  href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
<li><a  href='../src/custom-allocators.html'><b>7.11.</b> Пользовательские менеджеры памяти</a>
</li>
</ol>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/syntax-index.html'><b>9.</b> Syntax Index</a>
</li>
<li><a  href='../src/bibliography.html'><b>10.</b> Библиография</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Ссылки и заимствование</h1>
    <p>Эта глава является одной из трёх, описывающих систему владения ресурсами Rust.
Эта система представляет собой наиболее уникальную и привлекательную особенность
Rust, о которой разработчики должны иметь полное представление. Владение — это
то, как Rust достигает своей главной цели — безопасности памяти. Система
владения включает в себя несколько различных концепций, каждая из которых
рассматривается в своей собственной главе:</p>

<ul>
<li><a href="ownership.html">владение</a>, ключевая концепция</li>
<li>заимствование, её вы читаете сейчас</li>
<li><a href="lifetimes.html">время жизни</a>, расширение понятия заимствования</li>
</ul>

<p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все
три главы, чтобы полностью понять систему владения.</p>

<h1 id='Мета' class='section-header'><a href='#Мета'>Мета</a></h1>
<p>Прежде чем перейти к подробностям, отметим два важных момента в системе
владения.</p>

<p>Rust сфокусирован на безопасности и скорости. Это достигается за счёт
«абстракций с нулевой стоимостью» (zero-cost abstractions). Это значит, что в
Rust стоимость абстракций должна быть настолько малой, насколько это возможно
без ущерба для работоспособности. Система владения ресурсами — это яркий пример
абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом
руководстве, выполняется <em>во время компиляции</em>. Во время исполнения вы не
платите за какую-либо из возможностей ничего.</p>

<p>Тем не менее, эта система всё же имеет определённую стоимость: кривая обучения.
Многие новые пользователи Rust «борются с проверкой заимствования» — компилятор
Rust отказывается компилировать программу, которая по мнению автора является
абсолютно правильной. Это часто происходит потому, что мысленное представление
программиста о том, как должно работать владение, не совпадает с реальными
правилами, которыми оперирует Rust. Вы, наверное, поначалу также будете
испытывать подобные трудности. Однако существует и хорошая новость: более
опытные разработчики на Rust говорят, что чем больше они работают с правилами
системы владения, тем меньше они борются с компилятором.</p>

<p>Имея это в виду, давайте перейдём к изучению системы владения.</p>

<p><a name="borrowing"></a></p>

<h1 id='Заимствование' class='section-header'><a href='#Заимствование'>Заимствование</a></h1>
<p>В конце главы <a href="ownership.html">Владение</a> у нас была убогая функция, которая выглядела
так:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">v1</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>, <span class="ident">v2</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> (<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>, <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>, <span class="ident">i32</span>) {
    <span class="comment">// делаем что-нибудь с v1 и v2</span>

    <span class="comment">// возвращаем владение и результат нашей функции</span>
    (<span class="ident">v1</span>, <span class="ident">v2</span>, <span class="number">42</span>)
}

<span class="kw">let</span> <span class="ident">v1</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">v2</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="kw">let</span> (<span class="ident">v1</span>, <span class="ident">v2</span>, <span class="ident">answer</span>) <span class="op">=</span> <span class="ident">foo</span>(<span class="ident">v1</span>, <span class="ident">v2</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo(v1%3A%20Vec%3Ci32%3E%2C%20v2%3A%20Vec%3Ci32%3E)%20-%3E%20(Vec%3Ci32%3E%2C%20Vec%3Ci32%3E%2C%20i32)%20%7B%0A%20%20%20%20%2F%2F%20%D0%B4%D0%B5%D0%BB%D0%B0%D0%B5%D0%BC%20%D1%87%D1%82%D0%BE-%D0%BD%D0%B8%D0%B1%D1%83%D0%B4%D1%8C%20%D1%81%20v1%20%D0%B8%20v2%0A%0A%20%20%20%20%2F%2F%20%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%20%D0%B2%D0%BB%D0%B0%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%82%20%D0%BD%D0%B0%D1%88%D0%B5%D0%B9%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%0A%20%20%20%20(v1%2C%20v2%2C%2042)%0A%7D%0A%0Alet%20v1%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20v2%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Alet%20(v1%2C%20v2%2C%20answer)%20%3D%20foo(v1%2C%20v2)%3B%0A%7D">Run</a></pre>

<p>Однако, этот код не является идиоматичным с точки зрения Rust, так как он не
использует заимствование. Вот первый шаг:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">v1</span>: <span class="kw-2">&amp;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>, <span class="ident">v2</span>: <span class="kw-2">&amp;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="comment">// делаем что-нибудь с v1 и v2</span>

    <span class="comment">// возвращаем ответ</span>
    <span class="number">42</span>
}

<span class="kw">let</span> <span class="ident">v1</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">v2</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="kw">let</span> <span class="ident">answer</span> <span class="op">=</span> <span class="ident">foo</span>(<span class="kw-2">&amp;</span><span class="ident">v1</span>, <span class="kw-2">&amp;</span><span class="ident">v2</span>);

<span class="comment">// Мы можем и дальше использовать v1 и v2!</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo(v1%3A%20%26Vec%3Ci32%3E%2C%20v2%3A%20%26Vec%3Ci32%3E)%20-%3E%20i32%20%7B%0A%20%20%20%20%2F%2F%20%D0%B4%D0%B5%D0%BB%D0%B0%D0%B5%D0%BC%20%D1%87%D1%82%D0%BE-%D0%BD%D0%B8%D0%B1%D1%83%D0%B4%D1%8C%20%D1%81%20v1%20%D0%B8%20v2%0A%0A%20%20%20%20%2F%2F%20%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%20%D0%BE%D1%82%D0%B2%D0%B5%D1%82%0A%20%20%20%2042%0A%7D%0A%0Alet%20v1%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0Alet%20v2%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Alet%20answer%20%3D%20foo(%26v1%2C%20%26v2)%3B%0A%0A%2F%2F%20%D0%9C%D1%8B%20%D0%BC%D0%BE%D0%B6%D0%B5%D0%BC%20%D0%B8%20%D0%B4%D0%B0%D0%BB%D1%8C%D1%88%D0%B5%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20v1%20%D0%B8%20v2!%0A%7D">Run</a></pre>

<p>Вместо того, чтобы принимать <code>Vec&lt;i32&gt;</code> в качестве аргументов, мы будем
принимать ссылки: <code>&amp;Vec&lt;i32&gt;</code>. И вместо передачи <code>v1</code> и <code>v2</code> напрямую, мы будем
передавать <code>&amp;v1</code> и <code>&amp;v2</code>. Мы называем тип <code>&amp;T</code> «ссылка», и вместо того, чтобы
забирать владение ресурсом, она его заимствует. Имена, которые заимствуют что-
то, не освобождают ресурс, когда они выходят из области видимости. Это означает,
что, после вызова <code>foo()</code>, мы снова можем использовать наши исходные имена.</p>

<p>Ссылки являются неизменяемыми, как и имена. Это означает, что внутри <code>foo()</code>
векторы не могут быть изменены:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>) {
     <span class="ident">v</span>.<span class="ident">push</span>(<span class="number">5</span>);
}

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];

<span class="ident">foo</span>(<span class="kw-2">&amp;</span><span class="ident">v</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20foo(v%3A%20%26Vec%3Ci32%3E)%20%7B%0A%20%20%20%20%20v.push(5)%3B%0A%7D%0A%0Alet%20v%20%3D%20vec!%5B%5D%3B%0A%0Afoo(%26v)%3B%0A%7D">Run</a></pre>

<p>выдаёт ошибку:</p>

<pre><code class="language-text">error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
</code></pre>

<p>Добавление значения изменяет вектор, и поэтому компилятор не позволил нам это
сделать.</p>

<h1 id='Ссылки-mut' class='section-header'><a href='#Ссылки-mut'>Ссылки &amp;mut</a></h1>
<p>Вот второй вид ссылок: <code>&amp;mut T</code>. Это «изменяемая ссылка», которая позволяет
изменять ресурс, который вы заимствуете. Например:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">5</span>;
{
    <span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">x</span>;
    <span class="kw-2">*</span><span class="ident">y</span> <span class="op">+=</span> <span class="number">1</span>;
}
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">x</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20x%20%3D%205%3B%0A%7B%0A%20%20%20%20let%20y%20%3D%20%26mut%20x%3B%0A%20%20%20%20*y%20%2B%3D%201%3B%0A%7D%0Aprintln!(%22%7B%7D%22%2C%20x)%3B%0A%7D">Run</a></pre>

<p>Этот код напечатает <code>6</code>. Мы создали <code>y</code>, изменяемую ссылку на <code>x</code>, а затем
добавили единицу к значению, на которое указывает <code>y</code>. Следует отметить, что <code>x</code>
также должно быть помечено как <code>mut</code>. Если бы этого не было, то мы не могли бы
получить изменяемую ссылку неизменяемого значения.</p>

<p>Вы также заметили что мы добавили звездочку (<code>*</code>) перед <code>y</code>. Это сделано из-за того, 
что <code>y</code> - это ссылка и сама данных не содержит. Вам нужно использовать (<code>*</code>), для того
чтобы получить доступ непосредственно к содержимому на которое указывает ссылка.</p>

<p>Во всем остальном изменяемые ссылки (<code>&amp;mut</code>) такие же, как и неизменяемые (<code>&amp;</code>).
Однако, существует большая разница между этими двумя концепциями, и тем, как они
взаимодействуют. Вы можете сказать, что в приведённом выше примере есть что-то
подозрительное, потому что нам зачем-то понадобилась дополнительная область
видимости, созданная с помощью <code>{</code> и <code>}</code>. Если мы уберем эти скобки, то получим
ошибку:</p>

<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &amp;mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>

<p>Оказывается, есть определённые правила создания ссылок.</p>

<h1 id='Правила' class='section-header'><a href='#Правила'>Правила</a></h1>
<p>Вот правила заимствования в Rust.</p>

<p>Во-первых, область видимости любой ссылки должна находиться в пределах области
видимости владельца. Во-вторых, одновременно у вас может быть только один из
двух перечисленных ниже видов заимствования, но не оба сразу:</p>

<ul>
<li>одна или более неизменяемых ссылок (<code>&amp;T</code>) на ресурс;</li>
<li>ровно одна изменяемая ссылка (<code>&amp;mut T</code>) на ресурс.</li>
</ul>

<p>Вы можете заметить, что это похоже, хотя и не соответствует точно, определению
состояния гонки данных:</p>

<blockquote>
<p>Состояние «гонки данных» возникает, когда два или более указателей
осуществляют доступ к одной и той же области памяти одновременно, по крайней
мере один из них производит запись, и операции не синхронизированы.</p>
</blockquote>

<p>Что касается неизменяемых ссылок, то вы можете иметь их столько, сколько хотите,
так как ни одна из них не производит запись. Если же вы производите запись, и
вам нужно два или больше указателей на одну и ту же область памяти, то вы можете
иметь только одну <code>&amp;mut</code> одновременно. Так Rust предотвращает возникновение
состояния гонки данных во время компиляции: мы получим ошибку компиляции, если
нарушим эти правила.</p>

<p>Имея это в виду, давайте рассмотрим наш пример еще раз.</p>

<h2 id='Осмысливаем-области-видимости-thinking-in-scopes' class='section-header'><a href='#Осмысливаем-области-видимости-thinking-in-scopes'>Осмысливаем области видимости (Thinking in scopes)</a></h2>
<p>Вот код:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">5</span>;
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">x</span>;

<span class="kw-2">*</span><span class="ident">y</span> <span class="op">+=</span> <span class="number">1</span>;

<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">x</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20x%20%3D%205%3B%0Alet%20y%20%3D%20%26mut%20x%3B%0A%0A*y%20%2B%3D%201%3B%0A%0Aprintln!(%22%7B%7D%22%2C%20x)%3B%0A%7D">Run</a></pre>

<p>Этот код выдает нам такую ошибку:</p>

<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
</code></pre>

<p>Это потому, что мы нарушили правила: у нас есть изменяемая ссылка <code>&amp;mut T</code>,
указывающая на <code>x</code>, и поэтому мы не можем создать какую-либо <code>&amp;T</code>. Одно из двух.
Примечание подсказывает как следует рассматривать эту проблему:</p>

<pre><code class="language-text">note: previous borrow ends here
fn main() {

}
^
</code></pre>

<p>Другими словами, изменяемая ссылка сохраняется до конца нашего примера. А мы
хотим, чтобы изменяемое заимствование заканчивалось <em>до</em> того, как мы пытаемся
вызвать <code>println!</code> и создать неизменяемое заимствование. В Rust заимствование
привязано к области видимости, в которой оно является действительным. И эти
области видимости выглядят следующим образом:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">5</span>;

<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">x</span>;    <span class="comment">// -+ заимствование x через &amp;mut начинается здесь</span>
                   <span class="comment">//  |</span>
<span class="kw-2">*</span><span class="ident">y</span> <span class="op">+=</span> <span class="number">1</span>;           <span class="comment">//  |</span>
                   <span class="comment">//  |</span>
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">x</span>); <span class="comment">// -+ - пытаемся позаимствовать x здесь</span>
                   <span class="comment">// -+ заимствование x через &amp;mut заканчивается здесь</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20x%20%3D%205%3B%0A%0Alet%20y%20%3D%20%26mut%20x%3B%20%20%20%20%2F%2F%20-%2B%20%D0%B7%D0%B0%D0%B8%D0%BC%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20x%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20%26mut%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D0%B7%D0%B4%D0%B5%D1%81%D1%8C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%20%7C%0A*y%20%2B%3D%201%3B%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%20%7C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%20%7C%0Aprintln!(%22%7B%7D%22%2C%20x)%3B%20%2F%2F%20-%2B%20-%20%D0%BF%D1%8B%D1%82%D0%B0%D0%B5%D0%BC%D1%81%D1%8F%20%D0%BF%D0%BE%D0%B7%D0%B0%D0%B8%D0%BC%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20x%20%D0%B7%D0%B4%D0%B5%D1%81%D1%8C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20-%2B%20%D0%B7%D0%B0%D0%B8%D0%BC%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20x%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20%26mut%20%D0%B7%D0%B0%D0%BA%D0%B0%D0%BD%D1%87%D0%B8%D0%B2%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D0%B7%D0%B4%D0%B5%D1%81%D1%8C%0A%7D">Run</a></pre>

<p>Конфликт областей видимости: мы не можем создать <code>&amp;x</code> до тех пор, пока <code>y</code>
находится в области видимости.</p>

<p>Поэтому, когда мы добавляем фигурные скобки:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">5</span>;

{                   
    <span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">x</span>; <span class="comment">// -+ заимствование через &amp;mut начинается здесь</span>
    <span class="kw-2">*</span><span class="ident">y</span> <span class="op">+=</span> <span class="number">1</span>;        <span class="comment">//  |</span>
}                   <span class="comment">// -+ ... и заканчивается здесь</span>

<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">x</span>);  <span class="comment">// &lt;- пытаемся позаимствовать x здесь</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20x%20%3D%205%3B%0A%0A%7B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20let%20y%20%3D%20%26mut%20x%3B%20%2F%2F%20-%2B%20%D0%B7%D0%B0%D0%B8%D0%BC%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20%26mut%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D0%B7%D0%B4%D0%B5%D1%81%D1%8C%0A%20%20%20%20*y%20%2B%3D%201%3B%20%20%20%20%20%20%20%20%2F%2F%20%20%7C%0A%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20-%2B%20...%20%D0%B8%20%D0%B7%D0%B0%D0%BA%D0%B0%D0%BD%D1%87%D0%B8%D0%B2%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D0%B7%D0%B4%D0%B5%D1%81%D1%8C%0A%0Aprintln!(%22%7B%7D%22%2C%20x)%3B%20%20%2F%2F%20%3C-%20%D0%BF%D1%8B%D1%82%D0%B0%D0%B5%D0%BC%D1%81%D1%8F%20%D0%BF%D0%BE%D0%B7%D0%B0%D0%B8%D0%BC%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20x%20%D0%B7%D0%B4%D0%B5%D1%81%D1%8C%0A%7D">Run</a></pre>

<p>Никаких проблем нет. Наша изменяемая ссылка выходит из области видимости до
создания неизменяемой. Но область видимости является ключом к определению того,
как долго длится заимствование.</p>

<h2 id='Проблемы-которые-предотвращает-заимствование' class='section-header'><a href='#Проблемы-которые-предотвращает-заимствование'>Проблемы, которые предотвращает заимствование</a></h2>
<p>Почему нужны эти ограничивающие правила? Ну, как мы уже отметили, эти правила
предотвращают гонки данных. Какие виды проблем могут привести к состоянию гонки
данных? Вот некоторые из них.</p>

<h3 id='Недействительный-итератор' class='section-header'><a href='#Недействительный-итератор'>Недействительный итератор</a></h3>
<p>Одним из примеров является «недействительный итератор». Такое может произойти,
когда вы пытаетесь изменить коллекцию, которую в данный момент обходите.
Проверка заимствования Rust предотвращает это:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">v</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">i</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Afor%20i%20in%20%26v%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20i)%3B%0A%7D%0A%7D">Run</a></pre>

<p>Этот код печатает числа от одного до трёх. Когда мы обходим вектор, мы получаем
лишь ссылки на элементы. И сам <code>v</code> заимствован как неизменяемый, что означает,
что мы не можем изменить его в процессе обхода:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">v</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">i</span>);
    <span class="ident">v</span>.<span class="ident">push</span>(<span class="number">34</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20mut%20v%20%3D%20vec!%5B1%2C%202%2C%203%5D%3B%0A%0Afor%20i%20in%20%26v%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20i)%3B%0A%20%20%20%20v.push(34)%3B%0A%7D%0A%7D">Run</a></pre>

<p>Вот ошибка:</p>

<pre><code class="language-text">error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &amp;v {
          ^
note: previous borrow ends here
for i in &amp;v {
    println!(“{}”, i);
    v.push(34);
}
^
</code></pre>

<p>Мы не можем изменить <code>v</code>, потому что он уже заимствован в цикле.</p>

<h3 id='Использование-после-освобождения-use-after-free' class='section-header'><a href='#Использование-после-освобождения-use-after-free'>Использование после освобождения (use after free)</a></h3>
<p>Ссылки не должны жить дольше, чем ресурс, на который они ссылаются. Rust
проверяет области видимости ваших ссылок, чтобы удостовериться, что это правда.</p>

<p>Если Rust не будет проверять это свойство, то мы можем случайно использовать
ссылку, которая будет недействительна. Например:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">y</span>: <span class="kw-2">&amp;</span><span class="ident">i32</span>;
{
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">5</span>;
    <span class="ident">y</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">x</span>;
}

<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">y</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20y%3A%20%26i32%3B%0A%7B%0A%20%20%20%20let%20x%20%3D%205%3B%0A%20%20%20%20y%20%3D%20%26x%3B%0A%7D%0A%0Aprintln!(%22%7B%7D%22%2C%20y)%3B%0A%7D">Run</a></pre>

<p>Мы получим следующую ошибку:</p>

<pre><code class="language-text">error: `x` does not live long enough
    y = &amp;x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &amp;x;
}
</code></pre>

<p>Другими словами, <code>y</code> действителен только для той области видимости, где
существует <code>x</code>. Как только <code>x</code> выходит из области видимости, ссылка на него
становится недействительной. Таким образом, ошибка сообщает, что заимствование
«не живет достаточно долго» («does not live long enough»), потому что оно не
является действительным столько времени, сколько требуется.</p>

<p>Такая же проблема возникает, когда ссылка объявлена <em>перед</em> значением, на
которое она ссылается. Это происходит потому что ресурсы в одном блоке
освобождаются в порядке, противоположном порядку их объявления:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">y</span>: <span class="kw-2">&amp;</span><span class="ident">i32</span>;
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">5</span>;
<span class="ident">y</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">x</span>;

<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">y</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20y%3A%20%26i32%3B%0Alet%20x%20%3D%205%3B%0Ay%20%3D%20%26x%3B%0A%0Aprintln!(%22%7B%7D%22%2C%20y)%3B%0A%7D">Run</a></pre>

<p>Мы получим такую ошибку:</p>

<pre><code class="language-text">error: `x` does not live long enough
y = &amp;x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &amp;i32;
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}
</code></pre>

<p>В примере выше <code>y</code> объявлена перед <code>x</code>, т.е. живёт дольше <code>x</code>, а это запрещено.</p>

    <script src='../rustbook.js'></script>
</div></div>


</body>
</html>