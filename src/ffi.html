<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Интерфейс внешних функций (foreign function interface)</title>

    <link rel="stylesheet" type="text/css" href="../rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a  href='../src/getting-started.html'><b>3.</b> C чего начать</a>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ol class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a  href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ol>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>5.</b> Синтаксис и семантика</a>
<ol class='section'>
<li><a  href='../src/variable-bindings.html'><b>5.1.</b> Связывание имён</a>
</li>
<li><a  href='../src/functions.html'><b>5.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>5.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>5.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>5.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>5.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>5.7.</b> Владение</a>
</li>
<li><a  href='../src/references-and-borrowing.html'><b>5.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>5.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>5.10.</b> Изменяемость</a>
</li>
<li><a  href='../src/structs.html'><b>5.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>5.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>5.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>5.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>5.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>5.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>5.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>5.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>5.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>5.20.</b> Типаж `Drop`</a>
</li>
<li><a  href='../src/if-let.html'><b>5.21.</b> Конструкция `if let`</a>
</li>
<li><a  href='../src/trait-objects.html'><b>5.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>5.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>5.24.</b> Универсальный синтаксис вызова функций</a>
</li>
<li><a  href='../src/crates-and-modules.html'><b>5.25.</b> Контейнеры и модули</a>
</li>
<li><a  href='../src/const-and-static.html'><b>5.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>5.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>5.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>5.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>5.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>5.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>5.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>5.33.</b> Преобразования при разыменовании</a>
</li>
<li><a  href='../src/macros.html'><b>5.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>5.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>5.36.</b> Небезопасный код</a>
</li>
</ol>
</li>
<li><a  href='../src/effective-rust.html'><b>6.</b> Эффективное использование Rust</a>
<ol class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>6.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>6.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>6.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>6.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>6.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>6.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>6.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>6.8.</b> Выбор гарантий</a>
</li>
<li><a class='active' href='../src/ffi.html'><b>6.9.</b> Интерфейс внешних функций</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>6.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>6.11.</b> Каналы сборок</a>
</li>
<li><a  href='../src/using-rust-without-the-standard-library.html'><b>6.12.</b> Using Rust without the standard library</a>
</li>
</ol>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ol class='section'>
<li><a  href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a  href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
<li><a  href='../src/custom-allocators.html'><b>7.11.</b> Пользовательские менеджеры памяти</a>
</li>
</ol>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/syntax-index.html'><b>9.</b> Syntax Index</a>
</li>
<li><a  href='../src/bibliography.html'><b>10.</b> Библиография</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Интерфейс внешних функций (foreign function interface)</h1>
    
<h1 id='Введение' class='section-header'><a href='#Введение'>Введение</a></h1>
<p>В данном руководстве в качестве примера мы будем использовать
<a href="https://github.com/google/snappy">snappy</a>, библиотеку для сжатия/распаковки
данных. Мы реализуем Rust-интерфейс к этой библиотеке через вызов внешних
функций. Rust в настоящее время не в состоянии делать вызовы напрямую в
библиотеки C++, но snappy включает в себя интерфейс C (документирован в
<a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>).</p>

<p>Ниже приведен минимальный пример вызова внешней функции, который будет
скомпилирован при условии, что библиотека snappy установлена:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;
<span class="kw">use</span> <span class="ident">libc</span>::<span class="ident">size_t</span>;

<span class="attribute">#[<span class="ident">link</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;snappy&quot;</span>)]</span>
<span class="kw">extern</span> {
    <span class="kw">fn</span> <span class="ident">snappy_max_compressed_length</span>(<span class="ident">source_length</span>: <span class="ident">size_t</span>) <span class="op">-&gt;</span> <span class="ident">size_t</span>;
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">snappy_max_compressed_length</span>(<span class="number">100</span>) };
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;максимальный размер сжатого буфера длиной 100 байт: {}&quot;</span>, <span class="ident">x</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3Asize_t%3B%0A%0A%23%5Blink(name%20%3D%20%22snappy%22)%5D%0Aextern%20%7B%0A%20%20%20%20fn%20snappy_max_compressed_length(source_length%3A%20size_t)%20-%3E%20size_t%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%20unsafe%20%7B%20snappy_max_compressed_length(100)%20%7D%3B%0A%20%20%20%20println!(%22%D0%BC%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9%20%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%20%D1%81%D0%B6%D0%B0%D1%82%D0%BE%D0%B3%D0%BE%20%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B0%20%D0%B4%D0%BB%D0%B8%D0%BD%D0%BE%D0%B9%20100%20%D0%B1%D0%B0%D0%B9%D1%82%3A%20%7B%7D%22%2C%20x)%3B%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>Блок <code>extern</code> содержит список сигнатур функций из внешней библиотеки, в данном
случае для C ABI (application binary interface; двоичный интерфейс приложений)
данной платформы. Чтобы указать, что программу нужно компоновать с библиотекой
snappy, используется атрибут <code>#[link(...)]</code>. Благодаря этому, символы будут
успешно разрешены.</p>

<p>Предполагается, что внешние функции могут быть небезопасными, поэтому их вызовы
должны быть обёрнуты в блок <code>unsafe {}</code> как обещание компилятору, что все внутри
этого блока в действительности безопасно. Библиотеки C часто предоставляют
интерфейсы, которые не являются потоко-безопасными. И почти любая функция,
которая принимает в качестве аргумента указатель, не может принимать любое
входное значений, поскольку указатель может быть висячим; сырые указатели
выходят за пределы безопасной модели памяти в Rust.</p>

<p>При объявлении типов аргументов для внешней функции, компилятор Rust не может
проверить, является ли данное объявление корректным. Поэтому важно правильно
указать тип привязываемой функции — иначе ошибка обнаружится только во время
исполнения.</p>

<p>Блок <code>extern</code> может быть распространён на весь API snappy:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;
<span class="kw">use</span> <span class="ident">libc</span>::{<span class="ident">c_int</span>, <span class="ident">size_t</span>};

<span class="attribute">#[<span class="ident">link</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;snappy&quot;</span>)]</span>
<span class="kw">extern</span> {
    <span class="kw">fn</span> <span class="ident">snappy_compress</span>(<span class="ident">input</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>,
                       <span class="ident">input_length</span>: <span class="ident">size_t</span>,
                       <span class="ident">compressed</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>,
                       <span class="ident">compressed_length</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">size_t</span>) <span class="op">-&gt;</span> <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">snappy_uncompress</span>(<span class="ident">compressed</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>,
                         <span class="ident">compressed_length</span>: <span class="ident">size_t</span>,
                         <span class="ident">uncompressed</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>,
                         <span class="ident">uncompressed_length</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">size_t</span>) <span class="op">-&gt;</span> <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">snappy_max_compressed_length</span>(<span class="ident">source_length</span>: <span class="ident">size_t</span>) <span class="op">-&gt;</span> <span class="ident">size_t</span>;
    <span class="kw">fn</span> <span class="ident">snappy_uncompressed_length</span>(<span class="ident">compressed</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>,
                                  <span class="ident">compressed_length</span>: <span class="ident">size_t</span>,
                                  <span class="ident">result</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">size_t</span>) <span class="op">-&gt;</span> <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">snappy_validate_compressed_buffer</span>(<span class="ident">compressed</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>,
                                         <span class="ident">compressed_length</span>: <span class="ident">size_t</span>) <span class="op">-&gt;</span> <span class="ident">c_int</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3A%7Bc_int%2C%20size_t%7D%3B%0A%0A%23%5Blink(name%20%3D%20%22snappy%22)%5D%0Aextern%20%7B%0A%20%20%20%20fn%20snappy_compress(input%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20input_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20*mut%20size_t)%20-%3E%20c_int%3B%0A%20%20%20%20fn%20snappy_uncompress(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20uncompressed%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20uncompressed_length%3A%20*mut%20size_t)%20-%3E%20c_int%3B%0A%20%20%20%20fn%20snappy_max_compressed_length(source_length%3A%20size_t)%20-%3E%20size_t%3B%0A%20%20%20%20fn%20snappy_uncompressed_length(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20result%3A%20*mut%20size_t)%20-%3E%20c_int%3B%0A%20%20%20%20fn%20snappy_validate_compressed_buffer(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t)%20-%3E%20c_int%3B%0A%7D%0Afn%20main()%20%7B%7D%0A&amp;version=nightly">Run</a></pre>

<h1 id='Создание-безопасного-интерфейса' class='section-header'><a href='#Создание-безопасного-интерфейса'>Создание безопасного интерфейса</a></h1>
<p>Сырой C API (application programming interface; интерфейс программирования
приложений) необходимо обернуть, чтобы обеспечить безопасность памяти. Тогда мы
сможем использовать концепции более высокого уровня, такие как векторы.
Библиотека может выборочно открывать только безопасный, высокоуровневый
интерфейс и скрывать небезопасные внутренние детали.</p>

<p>Оборачивание функций, которые принимают в качестве входных параметров буферы,
включает в себя использование модуля <code>slice::raw</code> для управления векторами Rust
как указателями на память. Векторы Rust представляют собой гарантированно
непрерывный блок памяти. Длина — это количество элементов, которое в настоящее
время содержится в векторе, а ёмкость — общее количество выделенной памяти в
элементах. Длина меньше или равна ёмкости.</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">validate_compressed_buffer</span>(<span class="ident">src</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-&gt;</span> <span class="ident">bool</span> {
    <span class="kw">unsafe</span> {
        <span class="ident">snappy_validate_compressed_buffer</span>(<span class="ident">src</span>.<span class="ident">as_ptr</span>(), <span class="ident">src</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">size_t</span>) <span class="op">==</span> <span class="number">0</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3A%7Bc_int%2C%20size_t%7D%3B%0Aunsafe%20fn%20snappy_validate_compressed_buffer(_%3A%20*const%20u8%2C%20_%3A%20size_t)%20-%3E%20c_int%20%7B%200%20%7D%0Afn%20main()%20%7B%7D%0Apub%20fn%20validate_compressed_buffer(src%3A%20%26%5Bu8%5D)%20-%3E%20bool%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20snappy_validate_compressed_buffer(src.as_ptr()%2C%20src.len()%20as%20size_t)%20%3D%3D%200%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>Обёртка <code>validate_compressed_buffer</code> использует блок <code>unsafe</code>, но это
гарантирует, что её вызов будет безопасен для всех входных данных, поскольку
модификатор <code>unsafe</code> отсутствует в сигнатуре функции. Т.е. небезопасность скрыта
внутри функции и не видна вызывающему.</p>

<p>Функции <code>snappy_compress</code> и <code>snappy_uncompress</code> являются более сложными, так как
должен быть выделен буфер для хранения выходных данных.</p>

<p>Функция <code>snappy_max_compressed_length</code> может быть использована для выделения
вектора максимальной ёмкости, требуемой для хранения сжатых выходных данных.
Затем этот вектор может быть передан в функцию <code>snappy_compress</code> в качестве
выходного параметра. Ещё один параметр передается, чтобы получить настоящую
длину после сжатия и установить соответствующую длину вектора.</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">compress</span>(<span class="ident">src</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-&gt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">srclen</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">size_t</span>;
        <span class="kw">let</span> <span class="ident">psrc</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_ptr</span>();

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dstlen</span> <span class="op">=</span> <span class="ident">snappy_max_compressed_length</span>(<span class="ident">srclen</span>);
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dst</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="ident">dstlen</span> <span class="kw">as</span> <span class="ident">usize</span>);
        <span class="kw">let</span> <span class="ident">pdst</span> <span class="op">=</span> <span class="ident">dst</span>.<span class="ident">as_mut_ptr</span>();

        <span class="ident">snappy_compress</span>(<span class="ident">psrc</span>, <span class="ident">srclen</span>, <span class="ident">pdst</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dstlen</span>);
        <span class="ident">dst</span>.<span class="ident">set_len</span>(<span class="ident">dstlen</span> <span class="kw">as</span> <span class="ident">usize</span>);
        <span class="ident">dst</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3A%7Bsize_t%2C%20c_int%7D%3B%0Aunsafe%20fn%20snappy_compress(a%3A%20*const%20u8%2C%20b%3A%20size_t%2C%20c%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20d%3A%20*mut%20size_t)%20-%3E%20c_int%20%7B%200%20%7D%0Aunsafe%20fn%20snappy_max_compressed_length(a%3A%20size_t)%20-%3E%20size_t%20%7B%20a%20%7D%0Afn%20main()%20%7B%7D%0Apub%20fn%20compress(src%3A%20%26%5Bu8%5D)%20-%3E%20Vec%3Cu8%3E%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20let%20srclen%20%3D%20src.len()%20as%20size_t%3B%0A%20%20%20%20%20%20%20%20let%20psrc%20%3D%20src.as_ptr()%3B%0A%0A%20%20%20%20%20%20%20%20let%20mut%20dstlen%20%3D%20snappy_max_compressed_length(srclen)%3B%0A%20%20%20%20%20%20%20%20let%20mut%20dst%20%3D%20Vec%3A%3Awith_capacity(dstlen%20as%20usize)%3B%0A%20%20%20%20%20%20%20%20let%20pdst%20%3D%20dst.as_mut_ptr()%3B%0A%0A%20%20%20%20%20%20%20%20snappy_compress(psrc%2C%20srclen%2C%20pdst%2C%20%26mut%20dstlen)%3B%0A%20%20%20%20%20%20%20%20dst.set_len(dstlen%20as%20usize)%3B%0A%20%20%20%20%20%20%20%20dst%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>Распаковка аналогична, потому что snappy хранит размер несжатых данных как часть
формата сжатия, и <code>snappy_uncompressed_length</code> будет возвращать точный размер
необходимого буфера.</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">uncompress</span>(<span class="ident">src</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">srclen</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">size_t</span>;
        <span class="kw">let</span> <span class="ident">psrc</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_ptr</span>();

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dstlen</span>: <span class="ident">size_t</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="ident">snappy_uncompressed_length</span>(<span class="ident">psrc</span>, <span class="ident">srclen</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dstlen</span>);

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dst</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="ident">dstlen</span> <span class="kw">as</span> <span class="ident">usize</span>);
        <span class="kw">let</span> <span class="ident">pdst</span> <span class="op">=</span> <span class="ident">dst</span>.<span class="ident">as_mut_ptr</span>();

        <span class="kw">if</span> <span class="ident">snappy_uncompress</span>(<span class="ident">psrc</span>, <span class="ident">srclen</span>, <span class="ident">pdst</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dstlen</span>) <span class="op">==</span> <span class="number">0</span> {
            <span class="ident">dst</span>.<span class="ident">set_len</span>(<span class="ident">dstlen</span> <span class="kw">as</span> <span class="ident">usize</span>);
            <span class="prelude-val">Some</span>(<span class="ident">dst</span>)
        } <span class="kw">else</span> {
            <span class="prelude-val">None</span> <span class="comment">// SNAPPY_INVALID_INPUT</span>
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0Ause%20libc%3A%3A%7Bsize_t%2C%20c_int%7D%3B%0Aunsafe%20fn%20snappy_uncompress(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20uncompressed%3A%20*mut%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20uncompressed_length%3A%20*mut%20size_t)%20-%3E%20c_int%20%7B%200%20%7D%0Aunsafe%20fn%20snappy_uncompressed_length(compressed%3A%20*const%20u8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20compressed_length%3A%20size_t%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20result%3A%20*mut%20size_t)%20-%3E%20c_int%20%7B%200%20%7D%0Afn%20main()%20%7B%7D%0Apub%20fn%20uncompress(src%3A%20%26%5Bu8%5D)%20-%3E%20Option%3CVec%3Cu8%3E%3E%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20let%20srclen%20%3D%20src.len()%20as%20size_t%3B%0A%20%20%20%20%20%20%20%20let%20psrc%20%3D%20src.as_ptr()%3B%0A%0A%20%20%20%20%20%20%20%20let%20mut%20dstlen%3A%20size_t%20%3D%200%3B%0A%20%20%20%20%20%20%20%20snappy_uncompressed_length(psrc%2C%20srclen%2C%20%26mut%20dstlen)%3B%0A%0A%20%20%20%20%20%20%20%20let%20mut%20dst%20%3D%20Vec%3A%3Awith_capacity(dstlen%20as%20usize)%3B%0A%20%20%20%20%20%20%20%20let%20pdst%20%3D%20dst.as_mut_ptr()%3B%0A%0A%20%20%20%20%20%20%20%20if%20snappy_uncompress(psrc%2C%20srclen%2C%20pdst%2C%20%26mut%20dstlen)%20%3D%3D%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20dst.set_len(dstlen%20as%20usize)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(dst)%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20None%20%2F%2F%20SNAPPY_INVALID_INPUT%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>Для справки, примеры, используемые здесь, также доступны в библиотеке на
<a href="https://github.com/thestinger/rust-snappy">GitHub</a>.</p>

<h1 id='Деструкторы' class='section-header'><a href='#Деструкторы'>Деструкторы</a></h1>
<p>Внешние библиотеки часто передают владение ресурсами в вызывающий код. Когда это
происходит, мы должны использовать деструкторы Rust, чтобы обеспечить
безопасность и гарантировать освобождение этих ресурсов (особенно в случае
паники).</p>

<p>Чтобы получить более подробную информацию о деструкторах, смотрите
<a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">типаж Drop</a>.</p>

<h1 id='Обратные-вызовы-функций-rust-кодом-на-c-callbacks-from-c-code-to-rust' class='section-header'><a href='#Обратные-вызовы-функций-rust-кодом-на-c-callbacks-from-c-code-to-rust'>Обратные вызовы функций Rust кодом на C (Callbacks from C code to Rust</a></h1>
<h1 id='functions' class='section-header'><a href='#functions'>functions)</a></h1>
<p>Некоторые внешние библиотеки требуют использование обратных вызовов для передачи
вызывающей стороне отчета о своем текущем состоянии или промежуточных данных. Во
внешнюю библиотеку можно передавать функции, которые были определены в Rust. При
создании функции обратного вызова, которую можно вызывать из C кода, необходимо
указать для нее спецификатор <code>extern</code>, за которым следует подходящее соглашение
о вызове.</p>

<p>Затем функция обратного вызова может быть передана в библиотеку C через
регистрационный вызов, и уже затем может быть вызвана оттуда.</p>

<p>Простой пример:</p>

<p>Код на Rust:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">callback</span>(<span class="ident">a</span>: <span class="ident">i32</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Меня вызывают из C со значением {0}&quot;</span>, <span class="ident">a</span>);
}

<span class="attribute">#[<span class="ident">link</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;extlib&quot;</span>)]</span>
<span class="kw">extern</span> {
   <span class="kw">fn</span> <span class="ident">register_callback</span>(<span class="ident">cb</span>: <span class="kw">extern</span> <span class="kw">fn</span>(<span class="ident">i32</span>)) <span class="op">-&gt;</span> <span class="ident">i32</span>;
   <span class="kw">fn</span> <span class="ident">trigger_callback</span>();
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">unsafe</span> {
        <span class="ident">register_callback</span>(<span class="ident">callback</span>);
        <span class="ident">trigger_callback</span>(); <span class="comment">// Активация функции обратного вызова</span>
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=extern%20fn%20callback(a%3A%20i32)%20%7B%0A%20%20%20%20println!(%22%D0%9C%D0%B5%D0%BD%D1%8F%20%D0%B2%D1%8B%D0%B7%D1%8B%D0%B2%D0%B0%D1%8E%D1%82%20%D0%B8%D0%B7%20C%20%D1%81%D0%BE%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC%20%7B0%7D%22%2C%20a)%3B%0A%7D%0A%0A%23%5Blink(name%20%3D%20%22extlib%22)%5D%0Aextern%20%7B%0A%20%20%20fn%20register_callback(cb%3A%20extern%20fn(i32))%20-%3E%20i32%3B%0A%20%20%20fn%20trigger_callback()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20register_callback(callback)%3B%0A%20%20%20%20%20%20%20%20trigger_callback()%3B%20%2F%2F%20%D0%90%D0%BA%D1%82%D0%B8%D0%B2%D0%B0%D1%86%D0%B8%D1%8F%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>Код на C:</p>

<pre><code class="language-c">typedef void (*rust_callback)(int32_t);
rust_callback cb;

int32_t register_callback(rust_callback callback) {
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(7); // Вызовет callback(7) в Rust
}
</code></pre>

<p>В этом примере функция <code>main()</code> в Rust вызовет функцию <code>trigger_callback()</code> в C,
которая, в свою очередь, выполнит обратный вызов функции <code>callback()</code> в Rust.</p>

<h2 id='Обратные-вызовы-адресованные-объектам-rust-targeting-callbacks-to-rust' class='section-header'><a href='#Обратные-вызовы-адресованные-объектам-rust-targeting-callbacks-to-rust'>Обратные вызовы, адресованные объектам Rust (Targeting callbacks to Rust</a></h2>
<h2 id='objects' class='section-header'><a href='#objects'>objects)</a></h2>
<p>Предыдущий пример показал, как глобальная функция может быть вызвана из C кода.
Однако зачастую желательно, чтобы обратный вызов был адресован конкретному
объекту в Rust. Это может быть объект, который представляет собой обертку для
соответствующего объекта C.</p>

<p>Такое поведение может быть достигнуто путем передачи небезопасного указателя на
объект в библиотеку C. После чего библиотека C сможет передавать указатель на
объект Rust при обратном вызове. Это позволит получить небезопасный доступ к
объекту Rust, на которой сослались в обратном вызове.</p>

<p>Код на Rust:</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">C</span>)]</span>
<span class="kw">struct</span> <span class="ident">RustObject</span> {
    <span class="ident">a</span>: <span class="ident">i32</span>,
    <span class="comment">// другие поля</span>
}

<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">callback</span>(<span class="ident">target</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">RustObject</span>, <span class="ident">a</span>: <span class="ident">i32</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Меня вызывают из C со значением {0}&quot;</span>, <span class="ident">a</span>);
    <span class="kw">unsafe</span> {
        <span class="comment">// Меняем значение в RustObject на значение, полученное через функцию обратного вызова</span>
        (<span class="kw-2">*</span><span class="ident">target</span>).<span class="ident">a</span> <span class="op">=</span> <span class="ident">a</span>;
    }
}

<span class="attribute">#[<span class="ident">link</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;extlib&quot;</span>)]</span>
<span class="kw">extern</span> {
   <span class="kw">fn</span> <span class="ident">register_callback</span>(<span class="ident">target</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">RustObject</span>,
                        <span class="ident">cb</span>: <span class="kw">extern</span> <span class="kw">fn</span>(<span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">RustObject</span>, <span class="ident">i32</span>)) <span class="op">-&gt;</span> <span class="ident">i32</span>;
   <span class="kw">fn</span> <span class="ident">trigger_callback</span>();
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Создаём объект, на который будем ссылаться в функции обратного вызова</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rust_object</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">RustObject</span> { <span class="ident">a</span>: <span class="number">5</span> });

    <span class="kw">unsafe</span> {
        <span class="ident">register_callback</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">rust_object</span>, <span class="ident">callback</span>);
        <span class="ident">trigger_callback</span>();
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23%5Brepr(C)%5D%0Astruct%20RustObject%20%7B%0A%20%20%20%20a%3A%20i32%2C%0A%20%20%20%20%2F%2F%20%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5%20%D0%BF%D0%BE%D0%BB%D1%8F%0A%7D%0A%0Aextern%20%22C%22%20fn%20callback(target%3A%20*mut%20RustObject%2C%20a%3A%20i32)%20%7B%0A%20%20%20%20println!(%22%D0%9C%D0%B5%D0%BD%D1%8F%20%D0%B2%D1%8B%D0%B7%D1%8B%D0%B2%D0%B0%D1%8E%D1%82%20%D0%B8%D0%B7%20C%20%D1%81%D0%BE%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC%20%7B0%7D%22%2C%20a)%3B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20%D0%9C%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B2%20RustObject%20%D0%BD%D0%B0%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%2C%20%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8E%20%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0%0A%20%20%20%20%20%20%20%20(*target).a%20%3D%20a%3B%0A%20%20%20%20%7D%0A%7D%0A%0A%23%5Blink(name%20%3D%20%22extlib%22)%5D%0Aextern%20%7B%0A%20%20%20fn%20register_callback(target%3A%20*mut%20RustObject%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20cb%3A%20extern%20fn(*mut%20RustObject%2C%20i32))%20-%3E%20i32%3B%0A%20%20%20fn%20trigger_callback()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D1%91%D0%BC%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%2C%20%D0%BD%D0%B0%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9%20%D0%B1%D1%83%D0%B4%D0%B5%D0%BC%20%D1%81%D1%81%D1%8B%D0%BB%D0%B0%D1%82%D1%8C%D1%81%D1%8F%20%D0%B2%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0%0A%20%20%20%20let%20mut%20rust_object%20%3D%20Box%3A%3Anew(RustObject%20%7B%20a%3A%205%20%7D)%3B%0A%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20register_callback(%26mut%20*rust_object%2C%20callback)%3B%0A%20%20%20%20%20%20%20%20trigger_callback()%3B%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>Код на C:</p>

<pre><code class="language-c">typedef void (*rust_callback)(void*, int32_t);
void* cb_target;
rust_callback cb;

int32_t register_callback(void* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(cb_target, 7); // Вызовет callback(&amp;rustObject, 7) в Rust
}
</code></pre>

<h2 id='Асинхронные-обратные-вызовы' class='section-header'><a href='#Асинхронные-обратные-вызовы'>Асинхронные обратные вызовы</a></h2>
<p>В приведённых примерах обратные вызовы выполняются как непосредственная реакция
на вызов функции внешней библиотеки на C. Для выполнения обратного вызова поток
исполнения переключался из Rust в C, а затем снова в Rust, но, в конце концов,
обратный вызов выполнялся в том же потоке, из которого была вызвана функция,
инициировавшая обратный вызов.</p>

<p>Более сложная ситуация — это когда внешняя библиотека порождает свои собственные
потоки и осуществляет обратные вызовы из них. В этих случаях доступ к структурам
данных Rust из обратных вызовов особенно опасен, и поэтому нужно использовать
соответствующие механизмы синхронизации. Помимо классических механизмов
синхронизации, таких как мьютексы, в Rust есть еще одна возможность:
использовать каналы (<code>std::sync::mpsc::channel</code>), чтобы направить данные из
потока C, который выполнял обратный вызов, в поток Rust.</p>

<p>Если асинхронный обратный вызов адресован конкретному объекту в адресном
пространстве Rust, то необходимо, чтобы обратные вызовы не выполнялись
библиотекой C после уничтожения этого объекта Rust. Для этого следует,
во-первых, проектировать библиотеку таким образом, чтобы отмена регистрации
обратного вызова гарантировала, что он больше не будет выполняться. Во-вторых,
нужно отменить регистрацию обратного вызова в деструкторе объекта Rust, которому
адресован обратный вызов.</p>

<h1 id='Компоновка' class='section-header'><a href='#Компоновка'>Компоновка</a></h1>
<p>Атрибут <code>link</code> для блоков <code>extern</code> предоставляет <code>rustc</code> основные инструкции
относительно того, как он должен компоновать нативные библиотеки. На данный
момент есть две общепринятых формы записи атрибута <code>link</code>:</p>

<ul>
<li><code>#[link(name = &quot;foo&quot;)]</code></li>
<li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
</ul>

<p>В обоих этих случаях <code>foo</code> — это имя нативной библиотеки, с которой мы
компонуемся. Во втором случае <code>bar</code> — это тип нативной библиотеки, с которой
происходит компоновка. В настоящее время <code>rustc</code> известны три типа нативных
библиотек:</p>

<ul>
<li>Динамические — <code>#[link(name = &quot;readline&quot;)]</code></li>
<li>Статические — <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
<li>Фреймворки — <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></li>
</ul>

<p>Обратите внимание, что фреймворки доступны только для OSX.</p>

<p>Различные значения <code>kind</code> нужны, чтобы определить, как компоновать нативную
библиотеку. С точки зрения компоновки, компилятор Rust создает две разновидности
артефактов: промежуточный (rlib/статическая библиотека) и конечный (динамическая
библиотека/исполняемый файл). (Прим. переводчика: rlib — это формат статической
библиотеки с метаданными в формате Rust) Зависимости от нативных динамических
библиотек и фреймворков распространяются дальше, пока не дойдут до конечного
артефакта, а от статических библиотек — нет.</p>

<p>Вот несколько примеров того, как эта модель может быть использована:</p>

<ul>
<li><p>Нативная зависимость при сборке. Иногда написанный на Rust код необходимо
состыковать с некоторым кодом на C/C++, но распространение C/C++ кода в формате
библиотеки вызывает дополнительные трудности. В этом случае, код будут
упакован в <code>libfoo.a</code>, а затем контейнер Rust должен будет объявить
зависимость с помощью <code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>.</p>

<p>Независимо от типа результата (промежуточный или конечный) контейнера,
нативная статическая библиотека будет включена в него на выходе, поэтому нет
необходимости в распространении этой нативной статической библиотеки отдельно.</p></li>
<li><p>Обычная динамическая зависимость. Общие системные библиотеки (такие, как
<code>readline</code>) доступны на большом количестве систем, и статическую копию этих
библиотек часто сложно найти. Когда такая зависимость включена в контейнер
Rust, промежуточные артефакты (например, rlib&#39;ы) не будут компоноваться с
библиотекой, но когда rlib включается в состав конечного артефакта (например,
исполняемый файл), нативная библиотека будет прикомпонована.</p></li>
</ul>

<p>На OSX, фреймворки ведут себя так же, как и динамические библиотеки.</p>

<h1 id='Небезопасные-блоки' class='section-header'><a href='#Небезопасные-блоки'>Небезопасные блоки</a></h1>
<p>Некоторые операции, такие как разыменование небезопасных указателей или вызов
функций, которые были отмечены как небезопасные, разрешено использовать только
внутри небезопасных блоков. Небезопасные блоки изолируют опасные ситуации и дают
гарантии компилятору, что опасности не вытекут за пределы блока.</p>

<p>Небезопасные функции же, наоборот, показывают свою опасность всем. Небезопасная
функция записывается в виде:</p>

<pre class="rust rust-example-rendered">
<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">kaboom</span>(<span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> { <span class="kw-2">*</span><span class="ident">ptr</span> }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aunsafe%20fn%20kaboom(ptr%3A%20*const%20i32)%20-%3E%20i32%20%7B%20*ptr%20%7D%0A%7D">Run</a></pre>

<p>Эта функция может быть вызвана только из блока <code>unsafe</code> или из другой <code>unsafe</code>
функции.</p>

<h1 id='Доступ-к-внешним-глобальным-переменным' class='section-header'><a href='#Доступ-к-внешним-глобальным-переменным'>Доступ к внешним глобальным переменным</a></h1>
<p>Внешние API довольно часто экспортируют глобальные переменные, которые могут
быть использованы, например, для отслеживания глобального состояния. Для того,
чтобы получить доступ к этим переменным, нужно объявить их в блоке <code>extern</code>,
используя ключевое слово <code>static</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;

<span class="attribute">#[<span class="ident">link</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;readline&quot;</span>)]</span>
<span class="kw">extern</span> {
    <span class="kw">static</span> <span class="ident">rl_readline_version</span>: <span class="ident">libc</span>::<span class="ident">c_int</span>;
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;You have readline version {} installed.&quot;</span>,
             <span class="ident">rl_readline_version</span> <span class="kw">as</span> <span class="ident">i32</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0A%0A%23%5Blink(name%20%3D%20%22readline%22)%5D%0Aextern%20%7B%0A%20%20%20%20static%20rl_readline_version%3A%20libc%3A%3Ac_int%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22You%20have%20readline%20version%20%7B%7D%20installed.%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20rl_readline_version%20as%20i32)%3B%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>Кроме того, возможно, вам потребуется изменить глобальное состояние,
предоставленное внешним интерфейсом. Для этого при объявлении статических
переменных может быть добавлен модификатор <code>mut</code>, чтобы была возможность
изменять их.</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">ffi</span>::<span class="ident">CString</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">ptr</span>;

<span class="attribute">#[<span class="ident">link</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;readline&quot;</span>)]</span>
<span class="kw">extern</span> {
    <span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">rl_prompt</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">libc</span>::<span class="ident">c_char</span>;
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">prompt</span> <span class="op">=</span> <span class="ident">CString</span>::<span class="ident">new</span>(<span class="string">&quot;[my-awesome-shell] $&quot;</span>).<span class="ident">unwrap</span>();
    <span class="kw">unsafe</span> {
        <span class="ident">rl_prompt</span> <span class="op">=</span> <span class="ident">prompt</span>.<span class="ident">as_ptr</span>();

        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">rl_prompt</span>);

        <span class="ident">rl_prompt</span> <span class="op">=</span> <span class="ident">ptr</span>::<span class="ident">null</span>();
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0A%0Ause%20std%3A%3Affi%3A%3ACString%3B%0Ause%20std%3A%3Aptr%3B%0A%0A%23%5Blink(name%20%3D%20%22readline%22)%5D%0Aextern%20%7B%0A%20%20%20%20static%20mut%20rl_prompt%3A%20*const%20libc%3A%3Ac_char%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20prompt%20%3D%20CString%3A%3Anew(%22%5Bmy-awesome-shell%5D%20%24%22).unwrap()%3B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20rl_prompt%20%3D%20prompt.as_ptr()%3B%0A%0A%20%20%20%20%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20rl_prompt)%3B%0A%0A%20%20%20%20%20%20%20%20rl_prompt%20%3D%20ptr%3A%3Anull()%3B%0A%20%20%20%20%7D%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>Обратите внимание, что любое взаимодействие с <code>static mut</code> небезопасно — как
чтение, так и запись. Работа с изменяемым глобальным состоянием требует
значительно большей осторожности.</p>

<p><a name="foreign-calling-conventions"></a></p>

<h1 id='Соглашение-о-вызове-внешних-функций' class='section-header'><a href='#Соглашение-о-вызове-внешних-функций'>Соглашение о вызове внешних функций</a></h1>
<p>Большинство внешнего кода предоставляет C ABI. И Rust при вызове внешних функций
по умолчанию использует соглашение о вызове C для данной платформы. Но некоторые
внешние функции, в первую очередь Windows API, используют другое соглашение о
вызове. Rust обеспечивает способ указать компилятору, какое именно соглашение
использовать:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">all</span>(<span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;win32&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>))]</span>
<span class="attribute">#[<span class="ident">link</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;kernel32&quot;</span>)]</span>
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_snake_case</span>)]</span>
<span class="kw">extern</span> <span class="string">&quot;stdcall&quot;</span> {
    <span class="kw">fn</span> <span class="ident">SetEnvironmentVariableA</span>(<span class="ident">n</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>, <span class="ident">v</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>) <span class="op">-&gt;</span> <span class="ident">libc</span>::<span class="ident">c_int</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(libc)%5D%0Aextern%20crate%20libc%3B%0A%0A%23%5Bcfg(all(target_os%20%3D%20%22win32%22%2C%20target_arch%20%3D%20%22x86%22))%5D%0A%23%5Blink(name%20%3D%20%22kernel32%22)%5D%0A%23%5Ballow(non_snake_case)%5D%0Aextern%20%22stdcall%22%20%7B%0A%20%20%20%20fn%20SetEnvironmentVariableA(n%3A%20*const%20u8%2C%20v%3A%20*const%20u8)%20-%3E%20libc%3A%3Ac_int%3B%0A%7D%0Afn%20main()%20%7B%20%7D%0A&amp;version=nightly">Run</a></pre>

<p>Это указание относится ко всему блоку <code>extern</code>. Вот список поддерживаемых
ограничений для ABI:</p>

<ul>
<li><code>stdcall</code></li>
<li><code>aapcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
</ul>

<p>Большинство ABI в этом списке не требуют пояснений, но ABI <code>system</code> может
показаться немного странным. Он выбирает такое ABI, которое подходит для
взаимодействия с нативными библиотеками данной платформы. Например, на платформе
win32 с архитектурой x86, это означает, что будет использован ABI <code>stdcall</code>.
Однако, на windows x86_64 используется соглашение о вызове <code>C</code>, поэтому в этом
случае будет использован <code>C</code> ABI. Это означает, что в нашем предыдущем примере
мы могли бы использовать <code>extern &quot;system&quot; { ... }</code>, чтобы определить блок для
всех windows систем, а не только для x86.</p>

<h1 id='Взаимодействие-с-внешним-кодом' class='section-header'><a href='#Взаимодействие-с-внешним-кодом'>Взаимодействие с внешним кодом</a></h1>
<p>Rust гарантирует, что размещение полей <code>struct</code> совместимо с представлением в C
только в том случае, если к ней применяется атрибут <code>#[repr(C)]</code>. Атрибут
<code>#[repr(C, packed)]</code> может быть использован для размещения полей структуры без
выравнивания. Атрибут <code>#[repr(C)]</code> также может быть применен и к перечислениям.</p>

<p>Владеющие упаковки в Rust (<code>Box&lt;T&gt;</code>) используют указатели, не допускающие
нулевое значение (non-nullable), как дескрипторы содержащихся в них объектов.
Тем не менее, эти дескрипторы не должны создаваться вручную, так как они
управляются внутренними средствами выделения памяти. Ссылки можно без риска
считать ненулевыми указателями непосредственно на тип. Однако нарушение правил
проверки заимствования или изменяемости может быть небезопасным. Но компилятор
не может сделать так много предположений о сырых указателях. Например, он не
полагается на настоящую неизменяемость данных под неизменяемым сырым указателем.
Поэтому используйте сырые указатели (<code>*</code>), если вам необходимо намеренно
нарушить правила (но так, что при этом всё работает). Это нужно, чтобы
компилятор «случайно» не предположил относительно ссылок чего-то, что мы
собираемся нарушать (возможно, нам нужны несколько указателей с правом
изменения, что не допускается обычными ссылками).</p>

<p>Векторы и строки совместно используют одну и ту же базовую cхему размещения
памяти и утилиты, доступные в модулях <code>vec</code> и <code>str</code>, для работы с C API. Однако,
строки не завершаются нулевым байтом, <code>\0</code>. Если вам нужна строка, завершающаяся
нулевым байтом, для совместимости с C, вы должны использовать тип <code>CString</code> из
модуля <code>std::ffi</code>.</p>

<p>Стандартная библиотека включает в себя псевдонимы типов и определения функций
для стандартной библиотеки C в модуле <code>libc</code>, и Rust компонует <code>libc</code> и <code>libm</code>
по умолчанию.</p>

<h1 id='Оптимизация-указателей-допускающих-нулевое-значение' class='section-header'><a href='#Оптимизация-указателей-допускающих-нулевое-значение'>Оптимизация указателей, допускающих нулевое значение</a></h1>
<h1 id='the-nullable-pointer-optimization' class='section-header'><a href='#the-nullable-pointer-optimization'>(The nullable pointer optimization)</a></h1>
<p>Некоторые типы по определению не могут быть <code>null</code>. Это ссылки (<code>&amp;T</code>, <code>&amp;mut T</code>),
упаковки (<code>Box&lt;T&gt;</code>), указатели на функции (<code>extern &quot;abi&quot; fn()</code>). При
взаимодействии же с С часто используются указатели, которые могут быть <code>null</code>.
Как особый случай — обобщенный <code>enum</code>, который содержит ровно два варианта, один
из которых не содержит данных, а другой содержит одно поле. Такое использование
перечисления имеет право на «оптимизацию указателя, допускающего нулевое
значение». Когда создан экземпляр такого перечисления с одним из не-обнуляемых
типов, то он представляет собой ненулевой указатель для варианта, содержащего
данные, и нулевой — для варианта без данных. Таким образом, <code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code> — это представление указателя на функцию, допускающего
нулевое значение, и совместимого с C ABI.</p>

<h1 id='Вызов-кода-на-rust-из-кода-на-c' class='section-header'><a href='#Вызов-кода-на-rust-из-кода-на-c'>Вызов кода на Rust из кода на C</a></h1>
<p>Вы можете скомпилировать код на Rust таким образом, чтобы он мог быть вызван из
кода на C. Это довольно легко, но требует нескольких вещей:</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>
<span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">hello_rust</span>() <span class="op">-&gt;</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> {
    <span class="string">&quot;Hello, world!\0&quot;</span>.<span class="ident">as_ptr</span>()
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23%5Bno_mangle%5D%0Apub%20extern%20fn%20hello_rust()%20-%3E%20*const%20u8%20%7B%0A%20%20%20%20%22Hello%2C%20world!%5C0%22.as_ptr()%0A%7D%0Afn%20main()%20%7B%7D%0A">Run</a></pre>

<p><code>extern</code> указывает, что эта функцию придерживается соглашения о вызове C, как
описано выше в разделе
«<a href="ffi.html#foreign-calling-conventions">Соглашение о вызове внешних функций</a>».
Атрибут <code>no_mangle</code> выключает изменение имён, применяемое в Rust, чтобы было
легче компоноваться с этим кодом.</p>

    <script src='../rustbook.js'></script>
</div></div>


</body>
</html>