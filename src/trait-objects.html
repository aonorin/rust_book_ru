<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Типажи-объекты</title>

    <link rel="stylesheet" type="text/css" href="../rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a  href='../src/getting-started.html'><b>3.</b> C чего начать</a>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ol class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a  href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ol>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>5.</b> Синтаксис и семантика</a>
<ol class='section'>
<li><a  href='../src/variable-bindings.html'><b>5.1.</b> Связывание имён</a>
</li>
<li><a  href='../src/functions.html'><b>5.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>5.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>5.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>5.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>5.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>5.7.</b> Владение</a>
</li>
<li><a  href='../src/references-and-borrowing.html'><b>5.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>5.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>5.10.</b> Изменяемость</a>
</li>
<li><a  href='../src/structs.html'><b>5.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>5.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>5.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>5.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>5.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>5.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>5.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>5.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>5.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>5.20.</b> Типаж `Drop`</a>
</li>
<li><a  href='../src/if-let.html'><b>5.21.</b> Конструкция `if let`</a>
</li>
<li><a class='active' href='../src/trait-objects.html'><b>5.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>5.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>5.24.</b> Универсальный синтаксис вызова функций</a>
</li>
<li><a  href='../src/crates-and-modules.html'><b>5.25.</b> Контейнеры и модули</a>
</li>
<li><a  href='../src/const-and-static.html'><b>5.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>5.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>5.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>5.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>5.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>5.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>5.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>5.33.</b> Преобразования при разыменовании</a>
</li>
<li><a  href='../src/macros.html'><b>5.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>5.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>5.36.</b> Небезопасный код</a>
</li>
</ol>
</li>
<li><a  href='../src/effective-rust.html'><b>6.</b> Эффективное использование Rust</a>
<ol class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>6.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>6.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>6.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>6.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>6.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>6.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>6.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>6.8.</b> Выбор гарантий</a>
</li>
<li><a  href='../src/ffi.html'><b>6.9.</b> Интерфейс внешних функций</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>6.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>6.11.</b> Каналы сборок</a>
</li>
<li><a  href='../src/using-rust-without-the-standard-library.html'><b>6.12.</b> Using Rust without the standard library</a>
</li>
</ol>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ol class='section'>
<li><a  href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a  href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
<li><a  href='../src/custom-allocators.html'><b>7.11.</b> Пользовательские менеджеры памяти</a>
</li>
</ol>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/syntax-index.html'><b>9.</b> Syntax Index</a>
</li>
<li><a  href='../src/bibliography.html'><b>10.</b> Библиография</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Типажи-объекты</h1>
    <p>Когда код включает в себя полиморфизм, то должен быть механизм, чтобы
определить, какая конкретная версия будет фактически вызвана. Это называется
&#39;диспетчеризация.&#39; Есть две основные формы диспетчеризации: статическая и
динамическая. Хотя Rust и отдает предпочтение статической диспетчеризации, он
также поддерживает динамическую диспетчеризацию через механизм, называемый
&#39;типажи-объекты.&#39;</p>

<h2 id='Подготовка' class='section-header'><a href='#Подготовка'>Подготовка</a></h2>
<p>Для остальной части этой главы нам потребуется типаж и несколько его реализаций.
Давайте создадим простой типаж <code>Foo</code>. Он содержит один метод, который возвращает
<code>String</code>.</p>

<pre class="rust rust-example-rendered">
<span class="kw">trait</span> <span class="ident">Foo</span> {
    <span class="kw">fn</span> <span class="ident">method</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">String</span>;
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Foo%20%7B%0A%20%20%20%20fn%20method(%26self)%20-%3E%20String%3B%0A%7D%0A%7D">Run</a></pre>

<p>Также мы реализуем этот типаж для <code>u8</code> и <code>String</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">impl</span> <span class="ident">Foo</span> <span class="kw">for</span> <span class="ident">u8</span> {
    <span class="kw">fn</span> <span class="ident">method</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">String</span> { <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;u8: {}&quot;</span>, <span class="kw-2">*</span><span class="self">self</span>) }
}

<span class="kw">impl</span> <span class="ident">Foo</span> <span class="kw">for</span> <span class="ident">String</span> {
    <span class="kw">fn</span> <span class="ident">method</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">String</span> { <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;string: {}&quot;</span>, <span class="kw-2">*</span><span class="self">self</span>) }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Atrait%20Foo%20%7B%20fn%20method(%26self)%20-%3E%20String%3B%20%7D%0Aimpl%20Foo%20for%20u8%20%7B%0A%20%20%20%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22u8%3A%20%7B%7D%22%2C%20*self)%20%7D%0A%7D%0A%0Aimpl%20Foo%20for%20String%20%7B%0A%20%20%20%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22string%3A%20%7B%7D%22%2C%20*self)%20%7D%0A%7D%0A%7D">Run</a></pre>

<h2 id='Статическая-диспетчеризация' class='section-header'><a href='#Статическая-диспетчеризация'>Статическая диспетчеризация</a></h2>
<p>Мы можем использовать этот типаж для выполнения статической диспетчеризации с
помощью ограничения типажом:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">do_something</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Foo</span><span class="op">&gt;</span>(<span class="ident">x</span>: <span class="ident">T</span>) {
    <span class="ident">x</span>.<span class="ident">method</span>();
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">5u8</span>;
    <span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="string">&quot;Hello&quot;</span>.<span class="ident">to_string</span>();

    <span class="ident">do_something</span>(<span class="ident">x</span>);
    <span class="ident">do_something</span>(<span class="ident">y</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=trait%20Foo%20%7B%20fn%20method(%26self)%20-%3E%20String%3B%20%7D%0Aimpl%20Foo%20for%20u8%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22u8%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Aimpl%20Foo%20for%20String%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22string%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Afn%20do_something%3CT%3A%20Foo%3E(x%3A%20T)%20%7B%0A%20%20%20%20x.method()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%205u8%3B%0A%20%20%20%20let%20y%20%3D%20%22Hello%22.to_string()%3B%0A%0A%20%20%20%20do_something(x)%3B%0A%20%20%20%20do_something(y)%3B%0A%7D%0A">Run</a></pre>

<p>Здесь Rust использует &#39;мономорфизацию&#39; для статической диспетчеризации. Это
означает, что Rust создаст специальную версию <code>do_something()</code> для каждого из
типов: <code>u8</code> и <code>String</code>, а затем заменит все места вызовов на вызовы этих
специализированных функций. Другими словами, Rust сгенерирует нечто вроде этого:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">do_something_u8</span>(<span class="ident">x</span>: <span class="ident">u8</span>) {
    <span class="ident">x</span>.<span class="ident">method</span>();
}

<span class="kw">fn</span> <span class="ident">do_something_string</span>(<span class="ident">x</span>: <span class="ident">String</span>) {
    <span class="ident">x</span>.<span class="ident">method</span>();
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">5u8</span>;
    <span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="string">&quot;Hello&quot;</span>.<span class="ident">to_string</span>();

    <span class="ident">do_something_u8</span>(<span class="ident">x</span>);
    <span class="ident">do_something_string</span>(<span class="ident">y</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=trait%20Foo%20%7B%20fn%20method(%26self)%20-%3E%20String%3B%20%7D%0Aimpl%20Foo%20for%20u8%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22u8%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Aimpl%20Foo%20for%20String%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22string%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Afn%20do_something_u8(x%3A%20u8)%20%7B%0A%20%20%20%20x.method()%3B%0A%7D%0A%0Afn%20do_something_string(x%3A%20String)%20%7B%0A%20%20%20%20x.method()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%205u8%3B%0A%20%20%20%20let%20y%20%3D%20%22Hello%22.to_string()%3B%0A%0A%20%20%20%20do_something_u8(x)%3B%0A%20%20%20%20do_something_string(y)%3B%0A%7D%0A">Run</a></pre>

<p>Статическая диспетчеризация имеет большой потенциал: она позволяет вызывать
функцию, которая будет встроена, потому что вызываемая версия этой функции
известна на этапе компиляции, а встраивание — это ключ к хорошей оптимизации.
Статическая диспетчеризация быстра, но это достигается путем компромисса:
происходит &#39;раздувание кода&#39; в связи с большим количеством копий одной и той же
функции, по одной для каждого типа, расположенных в бинарном файле.</p>

<p>Кроме того, компиляторы не совершенны и могут «оптимизировать» код так, что он
станет медленнее. Например, встроенные функции будут слишком охотно раздувать
кэш команд (правила кэширования все вокруг нас). Это одна из причин, по которой
<code>#[inline]</code> и <code>#[inline(always)]</code> следует использовать осторожно, и почему
использование динамической диспетчеризации иногда более эффективно.</p>

<p>Тем не менее, в общем случае более эффективно использовать статическую
диспетчеризацию. Кроме того, всегда можно иметь тонкую статически-
диспетчеризуемую обертку для функции, которая выполняет динамическую
диспетчеризацию, но не наоборот. То есть статические вызовы являются более
гибкими. По этой причине стандартная библиотека старается быть статически
диспетчеризуемой везде, где это возможно.</p>

<h2 id='Динамическая-диспетчеризация' class='section-header'><a href='#Динамическая-диспетчеризация'>Динамическая диспетчеризация</a></h2>
<p>Rust обеспечивает динамическую диспетчеризацию через механизм под названием
&#39;типажи-объекты&#39;. Типажи-объекты, такие как <code>&amp;Foo</code> или <code>Box&lt;Foo&gt;</code>, это обычные
переменные, хранящие значения <em>любого</em> типа, реализующего данный типаж.
Конкретный тип типажа-объекта может быть определен только на этапе выполнения.</p>

<p>Типаж-объект может быть получен из указателя на конкретный тип, который
реализует этот типаж, путем его <code>явного приведения</code> (например, <code>&amp;x as &amp;Foo</code>) или
<code>неявного приведения</code> (например, используя <code>&amp;x</code> в качестве аргумента функции,
которая принимает <code>&amp;Foo</code>).</p>

<p>Явное и неявное приведение типажа-объекта также работает для таких указателей,
как <code>&amp;mut T</code> в <code>&amp;mut Foo</code> и <code>Box&lt;T&gt;</code> в <code>Box&lt;Foo&gt;</code>, но это все на данный момент.
Явное и неявное приведение идентичны.</p>

<p>Эта операция может рассматриваться как «затирание» знания компилятора о
конкретном типе указателя, поэтому типажи-объекты иногда называют «затиранием
типов».</p>

<p>Возвращаясь к примеру выше, мы можем использовать тот же самый типаж для
выполнения динамической диспетчеризации с типажами-объектами путем явного
приведения типа:</p>

<pre class="rust rust-example-rendered">

<span class="kw">fn</span> <span class="ident">do_something</span>(<span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">Foo</span>) {
    <span class="ident">x</span>.<span class="ident">method</span>();
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">5u8</span>;
    <span class="ident">do_something</span>(<span class="kw-2">&amp;</span><span class="ident">x</span> <span class="kw">as</span> <span class="kw-2">&amp;</span><span class="ident">Foo</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=trait%20Foo%20%7B%20fn%20method(%26self)%20-%3E%20String%3B%20%7D%0Aimpl%20Foo%20for%20u8%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22u8%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Aimpl%20Foo%20for%20String%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22string%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0A%0Afn%20do_something(x%3A%20%26Foo)%20%7B%0A%20%20%20%20x.method()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%205u8%3B%0A%20%20%20%20do_something(%26x%20as%20%26Foo)%3B%0A%7D%0A">Run</a></pre>

<p>или неявного приведения типа:</p>

<pre class="rust rust-example-rendered">

<span class="kw">fn</span> <span class="ident">do_something</span>(<span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">Foo</span>) {
    <span class="ident">x</span>.<span class="ident">method</span>();
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;Hello&quot;</span>.<span class="ident">to_string</span>();
    <span class="ident">do_something</span>(<span class="kw-2">&amp;</span><span class="ident">x</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=trait%20Foo%20%7B%20fn%20method(%26self)%20-%3E%20String%3B%20%7D%0Aimpl%20Foo%20for%20u8%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22u8%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0Aimpl%20Foo%20for%20String%20%7B%20fn%20method(%26self)%20-%3E%20String%20%7B%20format!(%22string%3A%20%7B%7D%22%2C%20*self)%20%7D%20%7D%0A%0Afn%20do_something(x%3A%20%26Foo)%20%7B%0A%20%20%20%20x.method()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%20%22Hello%22.to_string()%3B%0A%20%20%20%20do_something(%26x)%3B%0A%7D%0A">Run</a></pre>

<p>Функция, которая принимает типаж-объект, не обладает специализированными копиями
для каждого из типов, которые реализуют типаж <code>Foo</code>: генерируется только одна
копия. Часто (но не всегда), в результате происходит уменьшение раздувания кода.
Тем не менее, это происходит за счет более медленного вызова виртуальных
функций, и, по существу, блокирования любой возможности встраивания и связанных
с этим оптимизаций.</p>

<h3 id='Почему-указатели' class='section-header'><a href='#Почему-указатели'>Почему указатели?</a></h3>
<p>В отличие от многих управляемых языков, Rust по умолчанию не размещает значения
по указателю, так как типы могут иметь различные размеры. Знать размер значения
во время компиляции важно прежде всего для выполнения таких задач, как передача
значения в качестве аргумента в функцию, что вызывает помещение переданного
значения в стек, и выделение (и освобождение) места на куче для сохранения
значения там.</p>

<p>Для <code>Foo</code> допускается иметь значение, которое может быть либо <code>String</code> (24
байт), либо <code>u8</code> (1 байт), либо любой другой тип, для которого в соответствующих
крейтах может быть реализован <code>Foo</code> (возможно абсолютно любое число байт). Так
как этот другой тип может быть сколь угодно большими, то нет никакого способа,
гарантирующего, что последний вариант будет работать, если значения сохраняются
без указателя.</p>

<p>Размещение значения по указателю означает, что, когда мы имеем дело с типажом-
объектом, размер самого значения не важен, а важен лишь размер указателя.</p>

<h3 id='Представление' class='section-header'><a href='#Представление'>Представление</a></h3>
<p>Методы типажа можно вызвать для типажа-объекта с помощью специальной записи
указателей на функции, традиционно называемой &#39;виртуальная таблица&#39; (&#39;vtable&#39;)
(создается и управляется компилятором).</p>

<p>Типажи-объекты являются одновременно и простыми и сложными: их основное
представление и устройство довольно прямолинейно, но есть некоторые тонкости
относительно обнаружения сообщений об ошибках и странного поведения.</p>

<p>Давайте начнем с простого, с рантайм представления типажа-объекта. Модуль
<code>std::raw</code> содержит структуры с макетами, которые являются такими же, как и
сложные встроенные типы, <a href="http://doc.rust-lang.org/std/raw/struct.TraitObject.html">в том числе типажи-объекты</a>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">TraitObject</span> {
    <span class="kw">pub</span> <span class="ident">data</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> (),
    <span class="kw">pub</span> <span class="ident">vtable</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> (),
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Amod%20foo%20%7B%0Apub%20struct%20TraitObject%20%7B%0A%20%20%20%20pub%20data%3A%20*mut%20()%2C%0A%20%20%20%20pub%20vtable%3A%20*mut%20()%2C%0A%7D%0A%7D%0A%7D">Run</a></pre>

<p>То есть типаж-объект, такой как <code>&amp;Foo</code>, состоит из указателя на «данные» и
указателя на «виртуальную таблицу».</p>

<p>Указатель <code>data</code> адресует данные (какого-то неизвестного типа <code>T</code>), которые
хранит типаж-объект, а указатель <code>vtable</code> указывает на виртуальную таблицу
(«таблица виртуальных методов»), которая соответствует реализации <code>Foo</code> для <code>T</code>.</p>

<p>По существу, виртуальная таблица — это структура указателей на функции,
указывающих на конкретный кусок машинного кода для каждого метода в реализации.
Вызов метода наподобие <code>trait_object.method()</code> возвращает правильный указатель
из виртуальной таблицы, а затем динамически вызывает метод по этому указателю.
Например:</p>

<pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">FooVtable</span> {
    <span class="ident">destructor</span>: <span class="kw">fn</span>(<span class="kw-2">*</span><span class="kw-2">mut</span> ()),
    <span class="ident">size</span>: <span class="ident">usize</span>,
    <span class="ident">align</span>: <span class="ident">usize</span>,
    <span class="ident">method</span>: <span class="kw">fn</span>(<span class="kw-2">*</span><span class="kw">const</span> ()) <span class="op">-&gt;</span> <span class="ident">String</span>,
}

<span class="comment">// u8:</span>

<span class="kw">fn</span> <span class="ident">call_method_on_u8</span>(<span class="ident">x</span>: <span class="kw-2">*</span><span class="kw">const</span> ()) <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="comment">// компилятор гарантирует, что эта функция вызывается только</span>
    <span class="comment">// с `x`, указывающим на u8</span>
    <span class="kw">let</span> <span class="ident">byte</span>: <span class="kw-2">&amp;</span><span class="ident">u8</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span>(<span class="ident">x</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>) };

    <span class="ident">byte</span>.<span class="ident">method</span>()
}

<span class="kw">static</span> <span class="ident">Foo_for_u8_vtable</span>: <span class="ident">FooVtable</span> <span class="op">=</span> <span class="ident">FooVtable</span> {
    <span class="ident">destructor</span>: <span class="comment">/* магия компилятора */</span>,
    <span class="ident">size</span>: <span class="number">1</span>,
    <span class="ident">align</span>: <span class="number">1</span>,

    <span class="comment">// преобразование в указатель на функцию</span>
    <span class="ident">method</span>: <span class="ident">call_method_on_u8</span> <span class="kw">as</span> <span class="kw">fn</span>(<span class="kw-2">*</span><span class="kw">const</span> ()) <span class="op">-&gt;</span> <span class="ident">String</span>,
};


<span class="comment">// String:</span>

<span class="kw">fn</span> <span class="ident">call_method_on_String</span>(<span class="ident">x</span>: <span class="kw-2">*</span><span class="kw">const</span> ()) <span class="op">-&gt;</span> <span class="ident">String</span> {
    <span class="comment">// компилятор гарантирует, что эта функция вызывается только</span>
    <span class="comment">// с `x`, указывающим на String</span>
    <span class="kw">let</span> <span class="ident">string</span>: <span class="kw-2">&amp;</span><span class="ident">String</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span>(<span class="ident">x</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">String</span>) };

    <span class="ident">string</span>.<span class="ident">method</span>()
}

<span class="kw">static</span> <span class="ident">Foo_for_String_vtable</span>: <span class="ident">FooVtable</span> <span class="op">=</span> <span class="ident">FooVtable</span> {
    <span class="ident">destructor</span>: <span class="comment">/* магия компилятора */</span>,
    <span class="comment">// значения для 64-битного компьютера, для 32-битного они в 2 раза меньше</span>
    <span class="ident">size</span>: <span class="number">24</span>,
    <span class="ident">align</span>: <span class="number">8</span>,

    <span class="ident">method</span>: <span class="ident">call_method_on_String</span> <span class="kw">as</span> <span class="kw">fn</span>(<span class="kw-2">*</span><span class="kw">const</span> ()) <span class="op">-&gt;</span> <span class="ident">String</span>,
};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20FooVtable%20%7B%0A%20%20%20%20destructor%3A%20fn(*mut%20())%2C%0A%20%20%20%20size%3A%20usize%2C%0A%20%20%20%20align%3A%20usize%2C%0A%20%20%20%20method%3A%20fn(*const%20())%20-%3E%20String%2C%0A%7D%0A%0A%2F%2F%20u8%3A%0A%0Afn%20call_method_on_u8(x%3A%20*const%20())%20-%3E%20String%20%7B%0A%20%20%20%20%2F%2F%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%20%D0%B3%D0%B0%D1%80%D0%B0%D0%BD%D1%82%D0%B8%D1%80%D1%83%D0%B5%D1%82%2C%20%D1%87%D1%82%D0%BE%20%D1%8D%D1%82%D0%B0%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%20%D0%B2%D1%8B%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%0A%20%20%20%20%2F%2F%20%D1%81%20%60x%60%2C%20%D1%83%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D1%8E%D1%89%D0%B8%D0%BC%20%D0%BD%D0%B0%20u8%0A%20%20%20%20let%20byte%3A%20%26u8%20%3D%20unsafe%20%7B%20%26*(x%20as%20*const%20u8)%20%7D%3B%0A%0A%20%20%20%20byte.method()%0A%7D%0A%0Astatic%20Foo_for_u8_vtable%3A%20FooVtable%20%3D%20FooVtable%20%7B%0A%20%20%20%20destructor%3A%20%2F*%20%D0%BC%D0%B0%D0%B3%D0%B8%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0%20*%2F%2C%0A%20%20%20%20size%3A%201%2C%0A%20%20%20%20align%3A%201%2C%0A%0A%20%20%20%20%2F%2F%20%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B2%20%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%20%D0%BD%D0%B0%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8E%0A%20%20%20%20method%3A%20call_method_on_u8%20as%20fn(*const%20())%20-%3E%20String%2C%0A%7D%3B%0A%0A%0A%2F%2F%20String%3A%0A%0Afn%20call_method_on_String(x%3A%20*const%20())%20-%3E%20String%20%7B%0A%20%20%20%20%2F%2F%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%20%D0%B3%D0%B0%D1%80%D0%B0%D0%BD%D1%82%D0%B8%D1%80%D1%83%D0%B5%D1%82%2C%20%D1%87%D1%82%D0%BE%20%D1%8D%D1%82%D0%B0%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%20%D0%B2%D1%8B%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%0A%20%20%20%20%2F%2F%20%D1%81%20%60x%60%2C%20%D1%83%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D1%8E%D1%89%D0%B8%D0%BC%20%D0%BD%D0%B0%20String%0A%20%20%20%20let%20string%3A%20%26String%20%3D%20unsafe%20%7B%20%26*(x%20as%20*const%20String)%20%7D%3B%0A%0A%20%20%20%20string.method()%0A%7D%0A%0Astatic%20Foo_for_String_vtable%3A%20FooVtable%20%3D%20FooVtable%20%7B%0A%20%20%20%20destructor%3A%20%2F*%20%D0%BC%D0%B0%D0%B3%D0%B8%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0%20*%2F%2C%0A%20%20%20%20%2F%2F%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%B4%D0%BB%D1%8F%2064-%D0%B1%D0%B8%D1%82%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%B0%2C%20%D0%B4%D0%BB%D1%8F%2032-%D0%B1%D0%B8%D1%82%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BE%D0%BD%D0%B8%20%D0%B2%202%20%D1%80%D0%B0%D0%B7%D0%B0%20%D0%BC%D0%B5%D0%BD%D1%8C%D1%88%D0%B5%0A%20%20%20%20size%3A%2024%2C%0A%20%20%20%20align%3A%208%2C%0A%0A%20%20%20%20method%3A%20call_method_on_String%20as%20fn(*const%20())%20-%3E%20String%2C%0A%7D%3B%0A%7D">Run</a></pre>

<p>Поле <code>destructor</code> в каждой виртуальной таблице указывает на функцию, которая
будет очищать любые ресурсы типа этой виртуальной таблицы, для <code>u8</code> она
тривиальна, но для <code>String</code> она будет освобождать память. Это необходимо для
владельцев типажей-объектов, таких как <code>Box&lt;Foo&gt;</code>, для которых необходимо
очищать выделенную память как для <code>Box</code>, так и для внутреннего типа, когда они
выходят из области видимости. Поля <code>size</code> и <code>align</code> хранят размер затёртого
типа, и его требования к выравниванию; по существу, они не использовался в
момент, так как информация встроенного в деструктор, но будет использоваться в
будущем, так как объекты отличительным признакам постепенно становится более
гибким.</p>

<p>Предположим, у нас есть несколько значений, которые реализуют <code>Foo</code>, тогда явный
вид создания и использования типажей-объектов <code>Foo</code> может выглядеть примерно как
(игнорируются несоответствия типов: в любом случае, они всего лишь указатели):</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">a</span>: <span class="ident">String</span> <span class="op">=</span> <span class="string">&quot;foo&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="number">1</span>;

<span class="comment">// let b: &amp;Foo = &amp;a;</span>
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">TraitObject</span> {
    <span class="comment">// store the data</span>
    <span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="ident">a</span>,
    <span class="comment">// store the methods</span>
    <span class="ident">vtable</span>: <span class="kw-2">&amp;</span><span class="ident">Foo_for_String_vtable</span>
};

<span class="comment">// let y: &amp;Foo = x;</span>
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="ident">TraitObject</span> {
    <span class="comment">// store the data</span>
    <span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="ident">x</span>,
    <span class="comment">// store the methods</span>
    <span class="ident">vtable</span>: <span class="kw-2">&amp;</span><span class="ident">Foo_for_u8_vtable</span>
};

<span class="comment">// b.method();</span>
(<span class="ident">b</span>.<span class="ident">vtable</span>.<span class="ident">method</span>)(<span class="ident">b</span>.<span class="ident">data</span>);

<span class="comment">// y.method();</span>
(<span class="ident">y</span>.<span class="ident">vtable</span>.<span class="ident">method</span>)(<span class="ident">y</span>.<span class="ident">data</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20a%3A%20String%20%3D%20%22foo%22.to_string()%3B%0Alet%20x%3A%20u8%20%3D%201%3B%0A%0A%2F%2F%20let%20b%3A%20%26Foo%20%3D%20%26a%3B%0Alet%20b%20%3D%20TraitObject%20%7B%0A%20%20%20%20%2F%2F%20store%20the%20data%0A%20%20%20%20data%3A%20%26a%2C%0A%20%20%20%20%2F%2F%20store%20the%20methods%0A%20%20%20%20vtable%3A%20%26Foo_for_String_vtable%0A%7D%3B%0A%0A%2F%2F%20let%20y%3A%20%26Foo%20%3D%20x%3B%0Alet%20y%20%3D%20TraitObject%20%7B%0A%20%20%20%20%2F%2F%20store%20the%20data%0A%20%20%20%20data%3A%20%26x%2C%0A%20%20%20%20%2F%2F%20store%20the%20methods%0A%20%20%20%20vtable%3A%20%26Foo_for_u8_vtable%0A%7D%3B%0A%0A%2F%2F%20b.method()%3B%0A(b.vtable.method)(b.data)%3B%0A%0A%2F%2F%20y.method()%3B%0A(y.vtable.method)(y.data)%3B%0A%7D">Run</a></pre>

    <script src='../rustbook.js'></script>
</div></div>


</body>
</html>