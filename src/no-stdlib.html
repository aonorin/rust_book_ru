<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Без stdlib</title>

    <link rel="stylesheet" type="text/css" href="../rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a  href='../src/getting-started.html'><b>3.</b> C чего начать</a>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ol class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a  href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ol>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>5.</b> Синтаксис и семантика</a>
<ol class='section'>
<li><a  href='../src/variable-bindings.html'><b>5.1.</b> Связывание имён</a>
</li>
<li><a  href='../src/functions.html'><b>5.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>5.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>5.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>5.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>5.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>5.7.</b> Владение</a>
</li>
<li><a  href='../src/references-and-borrowing.html'><b>5.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>5.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>5.10.</b> Изменяемость</a>
</li>
<li><a  href='../src/structs.html'><b>5.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>5.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>5.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>5.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>5.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>5.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>5.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>5.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>5.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>5.20.</b> Типаж `Drop`</a>
</li>
<li><a  href='../src/if-let.html'><b>5.21.</b> Конструкция `if let`</a>
</li>
<li><a  href='../src/trait-objects.html'><b>5.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>5.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>5.24.</b> Универсальный синтаксис вызова функций</a>
</li>
<li><a  href='../src/crates-and-modules.html'><b>5.25.</b> Контейнеры и модули</a>
</li>
<li><a  href='../src/const-and-static.html'><b>5.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>5.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>5.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>5.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>5.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>5.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>5.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>5.33.</b> Преобразования при разыменовании</a>
</li>
<li><a  href='../src/macros.html'><b>5.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>5.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>5.36.</b> Небезопасный код</a>
</li>
</ol>
</li>
<li><a  href='../src/effective-rust.html'><b>6.</b> Эффективное использование Rust</a>
<ol class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>6.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>6.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>6.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>6.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>6.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>6.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>6.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>6.8.</b> Выбор гарантий</a>
</li>
<li><a  href='../src/ffi.html'><b>6.9.</b> Интерфейс внешних функций</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>6.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>6.11.</b> Каналы сборок</a>
</li>
<li><a  href='../src/using-rust-without-the-standard-library.html'><b>6.12.</b> Using Rust without the standard library</a>
</li>
</ol>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ol class='section'>
<li><a  href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a class='active' href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
<li><a  href='../src/custom-allocators.html'><b>7.11.</b> Пользовательские менеджеры памяти</a>
</li>
</ol>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/syntax-index.html'><b>9.</b> Syntax Index</a>
</li>
<li><a  href='../src/bibliography.html'><b>10.</b> Библиография</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Без stdlib</h1>
    <p>По умолчанию, <code>std</code> компонуется с каждым контейнером Rust. В некоторых случаях это
нежелательно, и этого можно избежать с помощью атрибута <code>#![no_std]</code>,
примененного (привязанного) к контейнеру.</p>

<pre class="rust rust-example-rendered">
<span class="comment">// a minimal library</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">crate_type</span><span class="op">=</span><span class="string">&quot;lib&quot;</span>]</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">feature</span>(<span class="ident">no_std</span>)]</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">no_std</span>]</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%2F%2F%20a%20minimal%20library%0A%23!%5Bcrate_type%3D%22lib%22%5D%0A%23!%5Bfeature(no_std)%5D%0A%23!%5Bno_std%5D%0A%2F%2F%20fn%20main()%20%7B%7D%20tricked%20you%2C%20rustdoc!%0A&amp;version=nightly">Run</a></pre>

<p>Очевидно, должно быть нечто большее, чем просто библиотеки: <code>#[no_std]</code> можно
использовать с исполняемыми контейнерами, а управлять точкой входа можно двумя
способами: с помощью атрибута <code>#[start]</code>, или с помощью переопределения
прокладки (shim) для C функции <code>main</code> по умолчанию на вашу собственную.</p>

<p>В функцию, помеченную атрибутом <code>#[start]</code>, передаются параметры командной
строки в том же формате, что и в C:</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#<span class="op">!</span>[<span class="ident">feature</span>(<span class="ident">lang_items</span>, <span class="ident">start</span>, <span class="ident">no_std</span>, <span class="ident">libc</span>)]</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">no_std</span>]</span>

<span class="comment">// Pull in the system libc library for what crt0.o likely requires</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;

<span class="comment">// Entry point for this program</span>
<span class="attribute">#[<span class="ident">start</span>]</span>
<span class="kw">fn</span> <span class="ident">start</span>(<span class="ident">_argc</span>: <span class="ident">isize</span>, <span class="ident">_argv</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>) <span class="op">-&gt;</span> <span class="ident">isize</span> {
    <span class="number">0</span>
}

<span class="comment">// These functions and traits are used by the compiler, but not</span>
<span class="comment">// for a bare-bones hello world. These are normally</span>
<span class="comment">// provided by libstd.</span>
<span class="attribute">#[<span class="ident">lang</span> <span class="op">=</span> <span class="string">&quot;stack_exhausted&quot;</span>]</span> <span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">stack_exhausted</span>() {}
<span class="attribute">#[<span class="ident">lang</span> <span class="op">=</span> <span class="string">&quot;eh_personality&quot;</span>]</span> <span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">eh_personality</span>() {}
<span class="attribute">#[<span class="ident">lang</span> <span class="op">=</span> <span class="string">&quot;panic_fmt&quot;</span>]</span> <span class="kw">fn</span> <span class="ident">panic_fmt</span>() <span class="op">-&gt;</span> <span class="op">!</span> { <span class="kw">loop</span> {} }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(lang_items%2C%20start%2C%20no_std%2C%20libc)%5D%0A%23!%5Bno_std%5D%0A%0A%2F%2F%20Pull%20in%20the%20system%20libc%20library%20for%20what%20crt0.o%20likely%20requires%0Aextern%20crate%20libc%3B%0A%0A%2F%2F%20Entry%20point%20for%20this%20program%0A%23%5Bstart%5D%0Afn%20start(_argc%3A%20isize%2C%20_argv%3A%20*const%20*const%20u8)%20-%3E%20isize%20%7B%0A%20%20%20%200%0A%7D%0A%0A%2F%2F%20These%20functions%20and%20traits%20are%20used%20by%20the%20compiler%2C%20but%20not%0A%2F%2F%20for%20a%20bare-bones%20hello%20world.%20These%20are%20normally%0A%2F%2F%20provided%20by%20libstd.%0A%23%5Blang%20%3D%20%22stack_exhausted%22%5D%20extern%20fn%20stack_exhausted()%20%7B%7D%0A%23%5Blang%20%3D%20%22eh_personality%22%5D%20extern%20fn%20eh_personality()%20%7B%7D%0A%23%5Blang%20%3D%20%22panic_fmt%22%5D%20fn%20panic_fmt()%20-%3E%20!%20%7B%20loop%20%7B%7D%20%7D%0A%2F%2F%20fn%20main()%20%7B%7D%20tricked%20you%2C%20rustdoc!%0A&amp;version=nightly">Run</a></pre>

<p>Чтобы переопределить вставленную компилятором прокладку <code>main</code>, нужно сначала
отключить ее с помощью <code>#![no_main]</code>, а затем создать соответствующий символ с
правильным ABI и правильным именем, что также потребует переопределение
искажения (коверкания) имен компилятором (<code>#[no_mangle]</code>):</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#<span class="op">!</span>[<span class="ident">feature</span>(<span class="ident">no_std</span>)]</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">no_std</span>]</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">no_main</span>]</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">feature</span>(<span class="ident">lang_items</span>, <span class="ident">start</span>)]</span>

<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;

<span class="attribute">#[<span class="ident">no_mangle</span>]</span> <span class="comment">// для уверенности в том, что этот символ будет называться `main` на выходе</span>
<span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">main</span>(<span class="ident">argc</span>: <span class="ident">i32</span>, <span class="ident">argv</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="number">0</span>
}

<span class="attribute">#[<span class="ident">lang</span> <span class="op">=</span> <span class="string">&quot;stack_exhausted&quot;</span>]</span> <span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">stack_exhausted</span>() {}
<span class="attribute">#[<span class="ident">lang</span> <span class="op">=</span> <span class="string">&quot;eh_personality&quot;</span>]</span> <span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">eh_personality</span>() {}
<span class="attribute">#[<span class="ident">lang</span> <span class="op">=</span> <span class="string">&quot;panic_fmt&quot;</span>]</span> <span class="kw">fn</span> <span class="ident">panic_fmt</span>() <span class="op">-&gt;</span> <span class="op">!</span> { <span class="kw">loop</span> {} }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(no_std)%5D%0A%23!%5Bno_std%5D%0A%23!%5Bno_main%5D%0A%23!%5Bfeature(lang_items%2C%20start)%5D%0A%0Aextern%20crate%20libc%3B%0A%0A%23%5Bno_mangle%5D%20%2F%2F%20%D0%B4%D0%BB%D1%8F%20%D1%83%D0%B2%D0%B5%D1%80%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20%D0%B2%20%D1%82%D0%BE%D0%BC%2C%20%D1%87%D1%82%D0%BE%20%D1%8D%D1%82%D0%BE%D1%82%20%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%20%D0%B1%D1%83%D0%B4%D0%B5%D1%82%20%D0%BD%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D1%82%D1%8C%D1%81%D1%8F%20%60main%60%20%D0%BD%D0%B0%20%D0%B2%D1%8B%D1%85%D0%BE%D0%B4%D0%B5%0Apub%20extern%20fn%20main(argc%3A%20i32%2C%20argv%3A%20*const%20*const%20u8)%20-%3E%20i32%20%7B%0A%20%20%20%200%0A%7D%0A%0A%23%5Blang%20%3D%20%22stack_exhausted%22%5D%20extern%20fn%20stack_exhausted()%20%7B%7D%0A%23%5Blang%20%3D%20%22eh_personality%22%5D%20extern%20fn%20eh_personality()%20%7B%7D%0A%23%5Blang%20%3D%20%22panic_fmt%22%5D%20fn%20panic_fmt()%20-%3E%20!%20%7B%20loop%20%7B%7D%20%7D%0A%2F%2F%20fn%20main()%20%7B%7D%20tricked%20you%2C%20rustdoc!%0A&amp;version=nightly">Run</a></pre>

<p>В настоящее время компилятор делает определенные предположения о символах,
которые доступны для вызова в исполняемом контейнере. Как правило, эти функции
предоставляются стандартной библиотекой, но если она не используется, то вы
должны определить их самостоятельно.</p>

<p>Первая из этих трех функций, <code>stack_exhausted</code>, вызывается тогда, когда
обнаруживается (происходит) переполнение стека. Эта функция имеет ряд
ограничений, касающихся того, как она может быть вызвана и того, что она должна
делать, но если регистр предела стека не поддерживается, то поток всегда имеет
«бесконечный стек» и эта функция не должна быть вызвана (получить управление,
срабатывать).</p>

<p>Вторая из этих трех функций, <code>eh_personality</code>, используется в механизме
обработки ошибок компилятора. Она часто отображается на функцию personality
(специализации) GCC (для получения дополнительной информации смотри <a href="http://doc.rust-lang.org/std/rt/unwind/index.html">реализацию
libstd</a>), но можно с
уверенностью сказать, что для контейнеров, которые не вызывают панику, эта
функция никогда не будет вызвана. Последняя функция, <code>panic_fmt</code>, также
используются в механизме обработки ошибок компилятора.</p>

<h2 id='Использование-основной-библиотеки-libcore' class='section-header'><a href='#Использование-основной-библиотеки-libcore'>Использование основной библиотеки (libcore)</a></h2>
<blockquote>
<p><strong>Примечание</strong>: структура основной библиотеки (core) является нестабильной, и
поэтому рекомендуется использовать стандартную библиотеку (std) там, где это
возможно.</p>
</blockquote>

<p>С учетом указанных выше методов, у нас есть чисто-металлический исполняемый код
работает Rust. Стандартная библиотека предоставляет немало функциональных
возможностей, однако, для Rust также важна производительность. Если стандартная
библиотека не соответствует этим требованиям, то вместо нее может быть
использована <a href="http://doc.rust-lang.org/core/index.html">libcore</a>.</p>

<p>Основная библиотека имеет очень мало зависимостей и гораздо более компактна, чем
стандартная библиотека. Кроме того, основная библиотека имеет большую часть
необходимой функциональности для написания идиоматического и эффективного кода
на Rust.</p>

<p>В качестве примера приведем программу, которая вычисляет скалярное произведение
двух векторов, предоставленных из кода C, и использует идиоматические практики
Rust.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#<span class="op">!</span>[<span class="ident">feature</span>(<span class="ident">lang_items</span>, <span class="ident">start</span>, <span class="ident">no_std</span>, <span class="ident">core</span>, <span class="ident">libc</span>)]</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">no_std</span>]</span>

<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">core</span>;

<span class="kw">use</span> <span class="ident">core</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">use</span> <span class="ident">core</span>::<span class="ident">mem</span>;

<span class="attribute">#[<span class="ident">no_mangle</span>]</span>
<span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">dot_product</span>(<span class="ident">a</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u32</span>, <span class="ident">a_len</span>: <span class="ident">u32</span>,
                          <span class="ident">b</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u32</span>, <span class="ident">b_len</span>: <span class="ident">u32</span>) <span class="op">-&gt;</span> <span class="ident">u32</span> {
    <span class="kw">use</span> <span class="ident">core</span>::<span class="ident">raw</span>::<span class="ident">Slice</span>;

    <span class="comment">// Convert the provided arrays into Rust slices.</span>
    <span class="comment">// The core::raw module guarantees that the Slice</span>
    <span class="comment">// structure has the same memory layout as a &amp;[T]</span>
    <span class="comment">// slice.</span>
    <span class="comment">//</span>
    <span class="comment">// This is an unsafe operation because the compiler</span>
    <span class="comment">// cannot tell the pointers are valid.</span>
    <span class="kw">let</span> (<span class="ident">a_slice</span>, <span class="ident">b_slice</span>): (<span class="kw-2">&amp;</span>[<span class="ident">u32</span>], <span class="kw-2">&amp;</span>[<span class="ident">u32</span>]) <span class="op">=</span> <span class="kw">unsafe</span> {
        <span class="ident">mem</span>::<span class="ident">transmute</span>((
            <span class="ident">Slice</span> { <span class="ident">data</span>: <span class="ident">a</span>, <span class="ident">len</span>: <span class="ident">a_len</span> <span class="kw">as</span> <span class="ident">usize</span> },
            <span class="ident">Slice</span> { <span class="ident">data</span>: <span class="ident">b</span>, <span class="ident">len</span>: <span class="ident">b_len</span> <span class="kw">as</span> <span class="ident">usize</span> },
        ))
    };

    <span class="comment">// Iterate over the slices, collecting the result</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ret</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">for</span> (<span class="ident">i</span>, <span class="ident">j</span>) <span class="kw">in</span> <span class="ident">a_slice</span>.<span class="ident">iter</span>().<span class="ident">zip</span>(<span class="ident">b_slice</span>.<span class="ident">iter</span>()) {
        <span class="ident">ret</span> <span class="op">+=</span> (<span class="kw-2">*</span><span class="ident">i</span>) <span class="op">*</span> (<span class="kw-2">*</span><span class="ident">j</span>);
    }
    <span class="kw">return</span> <span class="ident">ret</span>;
}

<span class="attribute">#[<span class="ident">lang</span> <span class="op">=</span> <span class="string">&quot;panic_fmt&quot;</span>]</span>
<span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">panic_fmt</span>(<span class="ident">args</span>: <span class="kw-2">&amp;</span><span class="ident">core</span>::<span class="ident">fmt</span>::<span class="ident">Arguments</span>,
                    <span class="ident">file</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>,
                    <span class="ident">line</span>: <span class="ident">u32</span>) <span class="op">-&gt;</span> <span class="op">!</span> {
    <span class="kw">loop</span> {}
}

<span class="attribute">#[<span class="ident">lang</span> <span class="op">=</span> <span class="string">&quot;stack_exhausted&quot;</span>]</span> <span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">stack_exhausted</span>() {}
<span class="attribute">#[<span class="ident">lang</span> <span class="op">=</span> <span class="string">&quot;eh_personality&quot;</span>]</span> <span class="kw">extern</span> <span class="kw">fn</span> <span class="ident">eh_personality</span>() {}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(lang_items%2C%20start%2C%20no_std%2C%20core%2C%20libc)%5D%0A%23!%5Bno_std%5D%0A%0Aextern%20crate%20libc%3B%0Aextern%20crate%20core%3B%0A%0Ause%20core%3A%3Aprelude%3A%3A*%3B%0A%0Ause%20core%3A%3Amem%3B%0A%0A%23%5Bno_mangle%5D%0Apub%20extern%20fn%20dot_product(a%3A%20*const%20u32%2C%20a_len%3A%20u32%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20b%3A%20*const%20u32%2C%20b_len%3A%20u32)%20-%3E%20u32%20%7B%0A%20%20%20%20use%20core%3A%3Araw%3A%3ASlice%3B%0A%0A%20%20%20%20%2F%2F%20Convert%20the%20provided%20arrays%20into%20Rust%20slices.%0A%20%20%20%20%2F%2F%20The%20core%3A%3Araw%20module%20guarantees%20that%20the%20Slice%0A%20%20%20%20%2F%2F%20structure%20has%20the%20same%20memory%20layout%20as%20a%20%26%5BT%5D%0A%20%20%20%20%2F%2F%20slice.%0A%20%20%20%20%2F%2F%0A%20%20%20%20%2F%2F%20This%20is%20an%20unsafe%20operation%20because%20the%20compiler%0A%20%20%20%20%2F%2F%20cannot%20tell%20the%20pointers%20are%20valid.%0A%20%20%20%20let%20(a_slice%2C%20b_slice)%3A%20(%26%5Bu32%5D%2C%20%26%5Bu32%5D)%20%3D%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20mem%3A%3Atransmute((%0A%20%20%20%20%20%20%20%20%20%20%20%20Slice%20%7B%20data%3A%20a%2C%20len%3A%20a_len%20as%20usize%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20Slice%20%7B%20data%3A%20b%2C%20len%3A%20b_len%20as%20usize%20%7D%2C%0A%20%20%20%20%20%20%20%20))%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20%2F%2F%20Iterate%20over%20the%20slices%2C%20collecting%20the%20result%0A%20%20%20%20let%20mut%20ret%20%3D%200%3B%0A%20%20%20%20for%20(i%2C%20j)%20in%20a_slice.iter().zip(b_slice.iter())%20%7B%0A%20%20%20%20%20%20%20%20ret%20%2B%3D%20(*i)%20*%20(*j)%3B%0A%20%20%20%20%7D%0A%20%20%20%20return%20ret%3B%0A%7D%0A%0A%23%5Blang%20%3D%20%22panic_fmt%22%5D%0Aextern%20fn%20panic_fmt(args%3A%20%26core%3A%3Afmt%3A%3AArguments%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20file%3A%20%26str%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20line%3A%20u32)%20-%3E%20!%20%7B%0A%20%20%20%20loop%20%7B%7D%0A%7D%0A%0A%23%5Blang%20%3D%20%22stack_exhausted%22%5D%20extern%20fn%20stack_exhausted()%20%7B%7D%0A%23%5Blang%20%3D%20%22eh_personality%22%5D%20extern%20fn%20eh_personality()%20%7B%7D%0A%23%5Bstart%5D%20fn%20start(argc%3A%20isize%2C%20argv%3A%20*const%20*const%20u8)%20-%3E%20isize%20%7B%200%20%7D%0Afn%20main()%20%7B%7D%0A&amp;version=nightly">Run</a></pre>

<p>Обратите внимание, что здесь, в отличае от примеров, рассмотренных выше, есть
один дополнительный lang элемент <code>panic_fmt</code>. Он должен быть определён
потребителями libcore, потому что основная библиотека объявляет панику, но не
определяет её. lang элемент <code>panic_fmt</code> определяет панику для этого
контейнера, и необходимо гарантировать, что он никогда не возвращает значение.</p>

<p>Как видно в этом примере, основная библиотека предназначена для предоставления
всей мощи Rust при любых обстоятельствах, независимо от требований платформы.
Дополнительные библиотеки, такие как liballoc, добавляют функциональность для
libcore, для работы которой нужно сделать некоторые платформо-зависимые
предположения; но эти библиотеки всё равно более переносимы, чем стандартная
библиотека в целом.</p>

    <script src='../rustbook.js'></script>
</div></div>


</body>
</html>