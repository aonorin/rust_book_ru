<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Плагины к компилятору</title>

    <link rel="stylesheet" type="text/css" href="../rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a  href='../src/getting-started.html'><b>3.</b> C чего начать</a>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ol class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a  href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ol>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>5.</b> Синтаксис и семантика</a>
<ol class='section'>
<li><a  href='../src/variable-bindings.html'><b>5.1.</b> Связывание имён</a>
</li>
<li><a  href='../src/functions.html'><b>5.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>5.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>5.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>5.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>5.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>5.7.</b> Владение</a>
</li>
<li><a  href='../src/references-and-borrowing.html'><b>5.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>5.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>5.10.</b> Изменяемость</a>
</li>
<li><a  href='../src/structs.html'><b>5.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>5.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>5.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>5.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>5.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>5.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>5.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>5.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>5.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>5.20.</b> Типаж `Drop`</a>
</li>
<li><a  href='../src/if-let.html'><b>5.21.</b> Конструкция `if let`</a>
</li>
<li><a  href='../src/trait-objects.html'><b>5.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>5.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>5.24.</b> Универсальный синтаксис вызова функций</a>
</li>
<li><a  href='../src/crates-and-modules.html'><b>5.25.</b> Контейнеры и модули</a>
</li>
<li><a  href='../src/const-and-static.html'><b>5.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>5.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>5.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>5.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>5.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>5.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>5.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>5.33.</b> Преобразования при разыменовании</a>
</li>
<li><a  href='../src/macros.html'><b>5.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>5.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>5.36.</b> Небезопасный код</a>
</li>
</ol>
</li>
<li><a  href='../src/effective-rust.html'><b>6.</b> Эффективное использование Rust</a>
<ol class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>6.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>6.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>6.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>6.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>6.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>6.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>6.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>6.8.</b> Выбор гарантий</a>
</li>
<li><a  href='../src/ffi.html'><b>6.9.</b> Интерфейс внешних функций</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>6.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>6.11.</b> Каналы сборок</a>
</li>
<li><a  href='../src/using-rust-without-the-standard-library.html'><b>6.12.</b> Using Rust without the standard library</a>
</li>
</ol>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ol class='section'>
<li><a class='active' href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a  href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
<li><a  href='../src/custom-allocators.html'><b>7.11.</b> Пользовательские менеджеры памяти</a>
</li>
</ol>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/syntax-index.html'><b>9.</b> Syntax Index</a>
</li>
<li><a  href='../src/bibliography.html'><b>10.</b> Библиография</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Плагины к компилятору</h1>
    
<h1 id='Введение' class='section-header'><a href='#Введение'>Введение</a></h1>
<p><code>rustc</code>, компилятор Rust, поддерживает плагины. Плагины — это разработанные
пользователями библиотеки, которые добавляют новые возможности в компилятор: это
могут быть расширения синтаксиса, дополнительные статические проверки (lints), и
другое.</p>

<p>Плагин — это контейнер, собираемый в динамическую библиотеку, и имеющий
отдельную функцию для регистрации расширения в <code>rustc</code>. Другие контейнеры могут
загружать эти расширения с помощью атрибута <code>#![plugin(...)]</code>. Также смотрите
раздел <a href="http://doc.rust-lang.org/rustc/plugin/index.html"><code>rustc::plugin</code></a> с
подробным описанием механизма определения и загрузки плагина.</p>

<p>Передаваемые в <code>#![plugin(foo(... args ...))]</code> аргументы не обрабатываются самим
<code>rustc</code>. Они передаются плагину с помощью
<a href="http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.args">метода <code>args</code></a>
структуры <code>Registry</code>.</p>

<p>В подавляющем большинстве случаев плагин должен использоваться <em>только</em> через
конструкцию <code>#![plugin]</code>, а не через <code>extern crate</code>. Компоновка потянула бы
внутренние библиотеки <code>libsyntax</code> и <code>librustc</code> как зависимости для вашего
контейнера. Обычно это нежелательно, и может потребоваться только если вы
собираете ещё один, другой, плагин. Статический анализ <code>plugin_as_library</code>
проверяет выполнение этой рекомендации.</p>

<p>Обычная практика — помещать плагины в отдельный контейнер, не содержащий
определений макросов (<code>macro_rules!</code>) и обычного кода на Rust, предназначенного
для непосредственно конечных пользователей библиотеки.</p>

<h1 id='Расширения-синтаксиса' class='section-header'><a href='#Расширения-синтаксиса'>Расширения синтаксиса</a></h1>
<p>Плагины могут по-разному расширять синтаксис Rust. Один из видов расширения
синтаксиса — это процедурные макросы. Они вызываются так же, как и
<a href="macros.html">обычные макросы</a>, но их раскрытие производится произвольным кодом
на Rust, который оперирует
<a href="http://doc.rust-lang.org/syntax/ast/index.html">синтаксическими деревьями</a> во
время компиляции.</p>

<p>Давайте напишем плагин
<a href="https://github.com/rust-lang/rust/tree/master/src/test/auxiliary/roman_numerals.rs"><code>roman_numerals.rs</code></a>,
который реализует целочисленные литералы с римскими цифрами.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#<span class="op">!</span>[<span class="ident">crate_type</span><span class="op">=</span><span class="string">&quot;dylib&quot;</span>]</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">feature</span>(<span class="ident">plugin_registrar</span>, <span class="ident">rustc_private</span>)]</span>

<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">syntax</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">rustc</span>;

<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">codemap</span>::<span class="ident">Span</span>;
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">parse</span>::<span class="ident">token</span>;
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">ast</span>::{<span class="ident">TokenTree</span>, <span class="ident">TtToken</span>};
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">ext</span>::<span class="ident">base</span>::{<span class="ident">ExtCtxt</span>, <span class="ident">MacResult</span>, <span class="ident">DummyResult</span>, <span class="ident">MacEager</span>};
<span class="kw">use</span> <span class="ident">syntax</span>::<span class="ident">ext</span>::<span class="ident">build</span>::<span class="ident">AstBuilder</span>;  <span class="comment">// типаж для expr_usize</span>
<span class="kw">use</span> <span class="ident">rustc</span>::<span class="ident">plugin</span>::<span class="ident">Registry</span>;

<span class="kw">fn</span> <span class="ident">expand_rn</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ExtCtxt</span>, <span class="ident">sp</span>: <span class="ident">Span</span>, <span class="ident">args</span>: <span class="kw-2">&amp;</span>[<span class="ident">TokenTree</span>])
        <span class="op">-&gt;</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">MacResult</span> <span class="op">+</span> <span class="lifetime">&#39;static</span><span class="op">&gt;</span> {

    <span class="kw">static</span> <span class="ident">NUMERALS</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> [(<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>, <span class="ident">u32</span>)] <span class="op">=</span> <span class="kw-2">&amp;</span>[
        (<span class="string">&quot;M&quot;</span>, <span class="number">1000</span>), (<span class="string">&quot;CM&quot;</span>, <span class="number">900</span>), (<span class="string">&quot;D&quot;</span>, <span class="number">500</span>), (<span class="string">&quot;CD&quot;</span>, <span class="number">400</span>),
        (<span class="string">&quot;C&quot;</span>,  <span class="number">100</span>), (<span class="string">&quot;XC&quot;</span>,  <span class="number">90</span>), (<span class="string">&quot;L&quot;</span>,  <span class="number">50</span>), (<span class="string">&quot;XL&quot;</span>,  <span class="number">40</span>),
        (<span class="string">&quot;X&quot;</span>,   <span class="number">10</span>), (<span class="string">&quot;IX&quot;</span>,   <span class="number">9</span>), (<span class="string">&quot;V&quot;</span>,   <span class="number">5</span>), (<span class="string">&quot;IV&quot;</span>,   <span class="number">4</span>),
        (<span class="string">&quot;I&quot;</span>,    <span class="number">1</span>)];

    <span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">args</span> {
        [<span class="ident">TtToken</span>(_, <span class="ident">token</span>::<span class="ident">Ident</span>(<span class="ident">s</span>, _))] <span class="op">=&gt;</span> <span class="ident">token</span>::<span class="ident">get_ident</span>(<span class="ident">s</span>).<span class="ident">to_string</span>(),
        _ <span class="op">=&gt;</span> {
            <span class="ident">cx</span>.<span class="ident">span_err</span>(<span class="ident">sp</span>, <span class="string">&quot;аргумент должен быть единственным идентификатором&quot;</span>);
            <span class="kw">return</span> <span class="ident">DummyResult</span>::<span class="ident">any</span>(<span class="ident">sp</span>);
        }
    };

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">text</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">text</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">total</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">while</span> <span class="op">!</span><span class="ident">text</span>.<span class="ident">is_empty</span>() {
        <span class="kw">match</span> <span class="ident">NUMERALS</span>.<span class="ident">iter</span>().<span class="ident">find</span>(<span class="op">|</span><span class="op">&amp;&amp;</span>(<span class="ident">rn</span>, _)<span class="op">|</span> <span class="ident">text</span>.<span class="ident">starts_with</span>(<span class="ident">rn</span>)) {
            <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>(<span class="ident">rn</span>, <span class="ident">val</span>)) <span class="op">=&gt;</span> {
                <span class="ident">total</span> <span class="op">+=</span> <span class="ident">val</span>;
                <span class="ident">text</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">text</span>[<span class="ident">rn</span>.<span class="ident">len</span>()..];
            }
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> {
                <span class="ident">cx</span>.<span class="ident">span_err</span>(<span class="ident">sp</span>, <span class="string">&quot;неправильное римское число&quot;</span>);
                <span class="kw">return</span> <span class="ident">DummyResult</span>::<span class="ident">any</span>(<span class="ident">sp</span>);
            }
        }
    }

    <span class="ident">MacEager</span>::<span class="ident">expr</span>(<span class="ident">cx</span>.<span class="ident">expr_u32</span>(<span class="ident">sp</span>, <span class="ident">total</span>))
}

<span class="attribute">#[<span class="ident">plugin_registrar</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">plugin_registrar</span>(<span class="ident">reg</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Registry</span>) {
    <span class="ident">reg</span>.<span class="ident">register_macro</span>(<span class="string">&quot;rn&quot;</span>, <span class="ident">expand_rn</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bcrate_type%3D%22dylib%22%5D%0A%23!%5Bfeature(plugin_registrar%2C%20rustc_private)%5D%0A%0Afn%20main()%20%7B%0Aextern%20crate%20syntax%3B%0Aextern%20crate%20rustc%3B%0A%0Ause%20syntax%3A%3Acodemap%3A%3ASpan%3B%0Ause%20syntax%3A%3Aparse%3A%3Atoken%3B%0Ause%20syntax%3A%3Aast%3A%3A%7BTokenTree%2C%20TtToken%7D%3B%0Ause%20syntax%3A%3Aext%3A%3Abase%3A%3A%7BExtCtxt%2C%20MacResult%2C%20DummyResult%2C%20MacEager%7D%3B%0Ause%20syntax%3A%3Aext%3A%3Abuild%3A%3AAstBuilder%3B%20%20%2F%2F%20%D1%82%D0%B8%D0%BF%D0%B0%D0%B6%20%D0%B4%D0%BB%D1%8F%20expr_usize%0Ause%20rustc%3A%3Aplugin%3A%3ARegistry%3B%0A%0Afn%20expand_rn(cx%3A%20%26mut%20ExtCtxt%2C%20sp%3A%20Span%2C%20args%3A%20%26%5BTokenTree%5D)%0A%20%20%20%20%20%20%20%20-%3E%20Box%3CMacResult%20%2B%20'static%3E%20%7B%0A%0A%20%20%20%20static%20NUMERALS%3A%20%26'static%20%5B(%26'static%20str%2C%20u32)%5D%20%3D%20%26%5B%0A%20%20%20%20%20%20%20%20(%22M%22%2C%201000)%2C%20(%22CM%22%2C%20900)%2C%20(%22D%22%2C%20500)%2C%20(%22CD%22%2C%20400)%2C%0A%20%20%20%20%20%20%20%20(%22C%22%2C%20%20100)%2C%20(%22XC%22%2C%20%2090)%2C%20(%22L%22%2C%20%2050)%2C%20(%22XL%22%2C%20%2040)%2C%0A%20%20%20%20%20%20%20%20(%22X%22%2C%20%20%2010)%2C%20(%22IX%22%2C%20%20%209)%2C%20(%22V%22%2C%20%20%205)%2C%20(%22IV%22%2C%20%20%204)%2C%0A%20%20%20%20%20%20%20%20(%22I%22%2C%20%20%20%201)%5D%3B%0A%0A%20%20%20%20let%20text%20%3D%20match%20args%20%7B%0A%20%20%20%20%20%20%20%20%5BTtToken(_%2C%20token%3A%3AIdent(s%2C%20_))%5D%20%3D%3E%20token%3A%3Aget_ident(s).to_string()%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20cx.span_err(sp%2C%20%22%D0%B0%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82%20%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B5%D0%B4%D0%B8%D0%BD%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%BC%20%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%BC%22)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20DummyResult%3A%3Aany(sp)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20mut%20text%20%3D%20%26*text%3B%0A%20%20%20%20let%20mut%20total%20%3D%200%3B%0A%20%20%20%20while%20!text.is_empty()%20%7B%0A%20%20%20%20%20%20%20%20match%20NUMERALS.iter().find(%7C%26%26(rn%2C%20_)%7C%20text.starts_with(rn))%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(%26(rn%2C%20val))%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20total%20%2B%3D%20val%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20text%20%3D%20%26text%5Brn.len()..%5D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20None%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20cx.span_err(sp%2C%20%22%D0%BD%D0%B5%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B8%D0%BC%D1%81%D0%BA%D0%BE%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%22)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20DummyResult%3A%3Aany(sp)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20MacEager%3A%3Aexpr(cx.expr_u32(sp%2C%20total))%0A%7D%0A%0A%23%5Bplugin_registrar%5D%0Apub%20fn%20plugin_registrar(reg%3A%20%26mut%20Registry)%20%7B%0A%20%20%20%20reg.register_macro(%22rn%22%2C%20expand_rn)%3B%0A%7D%0A%7D&amp;version=nightly">Run</a></pre>

<p>Теперь мы можем использовать <code>rn!()</code> как любой другой макрос:</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#<span class="op">!</span>[<span class="ident">feature</span>(<span class="ident">plugin</span>)]</span>
<span class="attribute">#<span class="op">!</span>[<span class="ident">plugin</span>(<span class="ident">roman_numerals</span>)]</span>

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">rn</span><span class="macro">!</span>(<span class="ident">MMXV</span>), <span class="number">2015</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bfeature(plugin)%5D%0A%23!%5Bplugin(roman_numerals)%5D%0A%0Afn%20main()%20%7B%0A%20%20%20%20assert_eq!(rn!(MMXV)%2C%202015)%3B%0A%7D%0A&amp;version=nightly">Run</a></pre>

<p>У этого подхода есть преимущества относительно простой функции <code>fn(&amp;str) -&gt; u32</code>:</p>

<ul>
<li>Преобразование (в общем случае, произвольной сложности) выполняется во время
компиляции;</li>
<li>Проверка правильности записи литерала также производится во время компиляции;</li>
<li>Можно добавить возможность использования литерала в образцах (patterns), что
по сути позволяет создавать литералы для любого типа данных.</li>
</ul>

<p>В дополнение к процедурным макросам, вы можете определять новые атрибуты
<a href="http://doc.rust-lang.org/reference.html#derive"><code>derive</code></a> и другие виды
расширений. Смотрите раздел
<a href="http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension"><code>Registry::register_syntax_extension</code></a>
и документацию
<a href="http://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html">перечисления <code>SyntaxExtension</code></a>.
В качестве более продвинутого примера с макросами, можно ознакомиться с
макросами регулярных выражений
<a href="https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs"><code>regex_macros</code></a>.</p>

<h2 id='Советы-и-хитрости' class='section-header'><a href='#Советы-и-хитрости'>Советы и хитрости</a></h2>
<p>Некоторые <a href="macros.html#debugging-macro-code">советы по отладке макросов</a>
применимы и в случае плагинов.</p>

<p>Можно использовать
<a href="http://doc.rust-lang.org/syntax/parse/index.html"><code>syntax::parse</code></a>, чтобы
преобразовать деревья токенов в высокоуровневые элементы синтаксиса, вроде
выражений:</p>

<pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">expand_foo</span>(<span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ExtCtxt</span>, <span class="ident">sp</span>: <span class="ident">Span</span>, <span class="ident">args</span>: <span class="kw-2">&amp;</span>[<span class="ident">TokenTree</span>])
        <span class="op">-&gt;</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">MacResult</span><span class="op">+</span><span class="lifetime">&#39;static</span><span class="op">&gt;</span> {

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">parser</span> <span class="op">=</span> <span class="ident">cx</span>.<span class="ident">new_parser_from_tts</span>(<span class="ident">args</span>);

    <span class="kw">let</span> <span class="ident">expr</span>: <span class="ident">P</span><span class="op">&lt;</span><span class="ident">Expr</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">parse_expr</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20expand_foo(cx%3A%20%26mut%20ExtCtxt%2C%20sp%3A%20Span%2C%20args%3A%20%26%5BTokenTree%5D)%0A%20%20%20%20%20%20%20%20-%3E%20Box%3CMacResult%2B'static%3E%20%7B%0A%0A%20%20%20%20let%20mut%20parser%20%3D%20cx.new_parser_from_tts(args)%3B%0A%0A%20%20%20%20let%20expr%3A%20P%3CExpr%3E%20%3D%20parser.parse_expr()%3B%0A%7D">Run</a></pre>

<p>Можно просмотреть код
<a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs">парсера <code>libsyntax</code></a>,
чтобы получить представление о работе инфраструктуры разбора.</p>

<p>Сохраняйте <a href="http://doc.rust-lang.org/syntax/codemap/struct.Span.html"><code>Span</code>ы</a>
всего, что вы разбираете, чтобы лучше сообщать об ошибках. Вы можете обернуть
ваши структуры данных в
<a href="http://doc.rust-lang.org/syntax/codemap/struct.Spanned.html"><code>Spanned</code></a>.</p>

<p>Вызов
<a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_fatal"><code>ExtCtxt::span_fatal</code></a>
сразу прервёт компиляцию. Вместо этого, лучше вызвать
<a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_err"><code>ExtCtxt::span_err</code></a>
и вернуть
<a href="http://doc.rust-lang.org/syntax/ext/base/struct.DummyResult.html"><code>DummyResult</code></a>,
чтобы компилятор мог продолжить работу и обнаружить дальнейшие ошибки.</p>

<p>Вы можете использовать
<a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_note"><code>span_note</code></a>
и
<a href="http://doc.rust-lang.org/syntax/print/pprust/index.html#functions"><code>syntax::print::pprust::*_to_string</code></a>
чтобы напечатать синтаксический фрагмент для отладки.</p>

<p>Пример выше создавал целочисленный литерал с помощью
<a href="http://doc.rust-lang.org/syntax/ext/build/trait.AstBuilder.html#tymethod.expr_usize"><code>AstBuilder::expr_usize</code></a>.
В качестве альтернативы типажу <code>AstBuilder</code>, <code>libsyntax</code> предоставляет набор
<a href="http://doc.rust-lang.org/syntax/ext/quote/index.html">макросов квазицитирования</a>.
Они не документированы и совсем не отполированы. Однако, эта реализация может
стать неплохой основой для улучшенной библиотеки квазицитирования, которая
работала бы как обычный плагин.</p>

<h1 id='Плагины-статических-проверок' class='section-header'><a href='#Плагины-статических-проверок'>Плагины статических проверок</a></h1>
<p>Плагины могут расширять
<a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">инфраструктуру статических проверок Rust</a>,
предоставляя новые проверки стиля кодирования, безопасности, и т.д. Полный
пример можно найти в
<a href="https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs"><code>src/test/auxiliary/lint_plugin_test.rs</code></a>.
Здесь мы приводим его суть:</p>

<pre class="rust rust-example-rendered">
<span class="macro">declare_lint</span><span class="macro">!</span>(<span class="ident">TEST_LINT</span>, <span class="ident">Warn</span>,
              <span class="string">&quot;Предупреждать об элементах, названных &#39;lintme&#39;&quot;</span>);

<span class="kw">struct</span> <span class="ident">Pass</span>;

<span class="kw">impl</span> <span class="ident">LintPass</span> <span class="kw">for</span> <span class="ident">Pass</span> {
    <span class="kw">fn</span> <span class="ident">get_lints</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">LintArray</span> {
        <span class="macro">lint_array</span><span class="macro">!</span>(<span class="ident">TEST_LINT</span>)
    }

    <span class="kw">fn</span> <span class="ident">check_item</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">cx</span>: <span class="kw-2">&amp;</span><span class="ident">Context</span>, <span class="ident">it</span>: <span class="kw-2">&amp;</span><span class="ident">ast</span>::<span class="ident">Item</span>) {
        <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">token</span>::<span class="ident">get_ident</span>(<span class="ident">it</span>.<span class="ident">ident</span>);
        <span class="kw">if</span> <span class="ident">name</span>.<span class="ident">get</span>() <span class="op">==</span> <span class="string">&quot;lintme&quot;</span> {
            <span class="ident">cx</span>.<span class="ident">span_lint</span>(<span class="ident">TEST_LINT</span>, <span class="ident">it</span>.<span class="ident">span</span>, <span class="string">&quot;элемент называется &#39;lintme&#39;&quot;</span>);
        }
    }
}

<span class="attribute">#[<span class="ident">plugin_registrar</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">plugin_registrar</span>(<span class="ident">reg</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Registry</span>) {
    <span class="ident">reg</span>.<span class="ident">register_lint_pass</span>(<span class="kw">box</span> <span class="ident">Pass</span> <span class="kw">as</span> <span class="ident">LintPassObject</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Adeclare_lint!(TEST_LINT%2C%20Warn%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22%D0%9F%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B0%D1%82%D1%8C%20%D0%BE%D0%B1%20%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%85%2C%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20'lintme'%22)%3B%0A%0Astruct%20Pass%3B%0A%0Aimpl%20LintPass%20for%20Pass%20%7B%0A%20%20%20%20fn%20get_lints(%26self)%20-%3E%20LintArray%20%7B%0A%20%20%20%20%20%20%20%20lint_array!(TEST_LINT)%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20check_item(%26mut%20self%2C%20cx%3A%20%26Context%2C%20it%3A%20%26ast%3A%3AItem)%20%7B%0A%20%20%20%20%20%20%20%20let%20name%20%3D%20token%3A%3Aget_ident(it.ident)%3B%0A%20%20%20%20%20%20%20%20if%20name.get()%20%3D%3D%20%22lintme%22%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20cx.span_lint(TEST_LINT%2C%20it.span%2C%20%22%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%20%D0%BD%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20'lintme'%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0A%23%5Bplugin_registrar%5D%0Apub%20fn%20plugin_registrar(reg%3A%20%26mut%20Registry)%20%7B%0A%20%20%20%20reg.register_lint_pass(box%20Pass%20as%20LintPassObject)%3B%0A%7D%0A%7D">Run</a></pre>

<p>Тогда код вроде</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#<span class="op">!</span>[<span class="ident">plugin</span>(<span class="ident">lint_plugin_test</span>)]</span>

<span class="kw">fn</span> <span class="ident">lintme</span>() { }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Bplugin(lint_plugin_test)%5D%0A%0Afn%20main()%20%7B%0Afn%20lintme()%20%7B%20%7D%0A%7D">Run</a></pre>

<p>выдаст предупреждение компилятора:</p>

<pre><code class="language-txt">foo.rs:4:1: 4:16 warning: item is named &#39;lintme&#39;, #[warn(test_lint)] on by default
foo.rs:4 fn lintme() { }
         ^~~~~~~~~~~~~~~
</code></pre>

<p>Плагин статического анализа состоит из следующих частей:</p>

<ul>
<li><p>один или больше вызовов <code>declare_lint!</code>, которые определяют статические
структуры <a href="http://doc.rust-lang.org/rustc/lint/struct.Lint.html"><code>Lint</code></a>;</p></li>
<li><p>структура, содержащая состояние, необходимое анализатору (в данном случае, его
нет);</p></li>
<li><p>реализация типажа
<a href="http://doc.rust-lang.org/rustc/lint/trait.LintPass.html"><code>LintPass</code></a>,
определяющая, как проверять каждый элемент синтаксиса. Один <code>LintPass</code> может
вызывать <code>span_lint</code> для нескольких различных <code>Lint</code>, но он должен
зарегистрировать их все через метод <code>get_lints</code>.</p></li>
</ul>

<p>Проходы статического анализатора — это обходы синтаксического дерева, но они
выполняются на поздних стадиях компиляции, когда уже доступа информация о типах.
Встроенные в <code>rustc</code>
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs">анализы</a>
в основном используют ту же инфраструктуру, что и плагины статического анализа.
Смотрите их исходный код, чтобы понять, как получать информацию о типах.</p>

<p>Статические проверки, определяемые плагинами, управляются обычными
<a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">атрибутами и флагами компилятора</a>,
т.е. <code>#[allow(test_lint)]</code> или <code>-A test-lint</code>. Эти идентификаторы выводятся из
первого аргумента <code>declare_lint!</code>, с учётом соответствующих преобразований
регистра букв и пунктуации.</p>

<p>Вы можете выполнить команду <code>rustc -W help foo.rs</code>, чтобы увидеть весь список
статических проверок, известных <code>rustc</code>, включая те, что загружаются
из<code>foo.rs</code>.</p>

    <script src='../rustbook.js'></script>
</div></div>


</body>
</html>